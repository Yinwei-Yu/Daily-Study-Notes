# 排序

## 概念

排除的稳定性：排序后关键字相同的元素间的相对位置不变

## 插入排序

### 直接插入

- 思路

将待排序序列分为有序区和无序区，每次将无序区中的头一个元素插入到有序区中的相应位置

~~~c++
void InserSort(vector<int>& R)
{
    int n=R.size();
    for(int i=1;i<n;i++)
    {
        if(R[i]<R[i-1])//无序区的第一个元素小于有序区的最后一个元素
        {
            int tmp=R[i];//记录无序区的第一个元素
            int j=i-1;//从有序区最后一个元素开始往前查找要插入的位置
            while(j>=0&&R[j]>tmp)//当无序区的第一个元素
            {
                R[j+1]=R[j];
                j--;
            }
            R[j+1]=tmp;
        }
    }
}
~~~

- 分析

最好$O(n)$,最坏$O(n^2)$，平均$O(n^2)$，稳定

### 折半插入

- 思路

无序区和有序区，在无序区查找插入位置时，用折半查找

~~~c++
void BinaryInsertSort(vector<int>&R)
{
    int n=R.size();
    for(int i=1;i<n;i++)
    {
        if(R[i]<R[i-1])
        {
            int temp=R[i];
            int low=0;int high=i-1;
            while(low<=high)
            {
                int mid=(low+high)/2;
                if(temp>R[mid])
                    low=mid+1;
                else(temp<R[mid])
                    high=mid-1;
            }						//折半查找过程
            for(int j=i-1;j>=high+1;j--)
            {
                R[j]=R[j-1];
            }
            R[high+1]=temp;
        }
    }
}
~~~

- 分析

$O(n^2)$，空间复杂度$O(1)$，稳定

### 希尔排序

- 思路

分组插入排序，以d为组间元素步长，逐步减半，知道最后d=1，对整体线性表再做一次插入排序

~~~c++
void ShellSort(vector<int>&R)
{
    int n=R.size();
    int d=n/2;
    while(d>0)
    {
        for(int i=d;i<n;i++)//将直接插入排序的1改为d
        {
            if(R[i]<R[i-d])
            {
                int tmp=R[i];
                int j=i-d;
                while(j>=0&&R[j]>tmp)
                {
                    R[j+d]=R[j];
                    j-=d;
                }
                R[j+d]=tmp;
            }
        }
        d=d/2;//减小增量
    }
}
~~~

- 分析

$O(n^{1.58})$，不稳定

## 交换排序

### 冒泡排序

分为有序区和无序区，每次扫描将无序区中最小的一个放到有序区。方法是无序区相邻元素之间比较和位置交换。若一趟中没有任何元素进行了交换，则说明排序已完成

~~~c++
void BubbleSort(vector<int>&R)
{
    int n=R.size();
    for(int i=0;i<n;i++)
    {
        bool exchange=false;
        for(int j=n-1;j>i;j--)//从后往前遍历找出最小元素
        {
            if(R[j-1]>R[j])
            {
                swap(R[j-1],R[j]);
                exchange=true;//发生交换则置为已交换
            }
        }
        if(exchange==false)//没有发生交换，说明排序完成
            return;
    }
}
~~~

- 分析

最好$O(n)$,最坏$O(n^2)$,空间$O(1)$,稳定

### 快速排序

- 思路

在长度大于1的有序表中选取第一个元素作为基准，将其归位。所有小于基准的元素在左边，大于基准的元素在右边。对基准左右的元素递归进行以上过程，知道子表的长度为1或者0，则为有序的。

对$R[s...t]$的递归模型如下：

$\qquad f(R,s,t)=不做任何事$

$\qquad f(R,s,t)=划分后基准位置为i；$

$\qquad\qquad f(R,s,i-1);f(R,i+1,t);$

==快速排序每次仅将一个元素归位==

~~~c++
void QuickSort(vector<int>&R,int low,int high)
{
    if(low>=high)
        return;//重要!!!作为递归出口！
    int i=low;//基准元素
    int j=low+1;//从基准后面一个开始扫描
    int pivot=R[low];//存储基准元素
    while(j<=high)
    {
        if(R[j]<=pivot)
        {
            i++;
            if(i!=j)//容易忽略！
            swap(R[i],R[j]);
        }
        j++;
    }
    swap(R[low],R[i]);//进行一趟划分，将基准归位
    QuickSort(R,low,i-1);
    QuickSort(R,i+1,high);
}
~~~

- 分析
  - 主要时间花费在划分上
  - 每层划分的元素个数最多为n
  - 排序时间取决于树的高度
  - 因为不同的初始序列对应的递归树高度不同，所以快速排序的时间受到初始排序表影响
  - 时间：最好$O(nlog_2n)$，最坏$O(n^2)$，平均$O(nlog_2n)$
  - 空间：最好$O(nlog_2n)$，最坏$O(n)$，平均$O(nlog_2n)$​    ==取决于递归树的高度==
  - 不稳定

## 选择排序

### 简单选择排序

从无序区中选择一个最小的元素放在有序区

~~~c++
void SelectSort(vector<int>&R)
{
    int n=R.size();
    for(int i=0;i<n;i++)//第i趟排序，有序区[i...i-1]，i代表有序区元素的个数
    {
        int minj=i;//将最小值置为无序区第一个
        for(int j=i+1;j<n;j++)//在无序区中找最小元素R[minj]
        {
            if(R[j]<R[minj])//小
                minj=j;//更新minj的值
        }
        if(minj!=i)//如果发生变化
            swap(R[i],R[minj]);//交换两者的值
    }
}
~~~

- 分析
  - 时间：$O(n^2)$
  - 空间：$O(1)$
  - 不稳定

### 堆排序

堆排序利用完全二叉树代替选择排序

- 复习

  - 二叉树若根节点编号为0，则自上到下从左到右编号为i的结点的左孩子编号为2i+1，右孩子为2i+2

  - 最后一个分支节点的编号为$\lfloor n/2 \rfloor-1$

- 小根堆：$k_i\le k_{2i+1}且k_i\le k_{2i+2}$
- 大根堆：$k_i\ge k_{2i+1}且k_i\ge k_{2i+2}$

以大根堆为例讨论：

每次将序列调整为大根堆后，第一个元素一定为最大元素。将第一个元素放在有序区（在无序区之后）的最前面（有序区里的元素一定比无序区的元素大）

- 堆排序的核心是筛选出最大元素的过程，用于将一个完全二叉树调整为大根堆。这个完全二叉树是：
  - 左右子树都是大根堆，但加入根节点后不再是大根堆

筛选大根堆的过程如下：

- 先让i指向根节点R\[low]，将根节点的值记录为temp，j指向他的左孩子R\[2low+1]，在j<=high时循环

- 若R\[i]的右孩子R\[2i+2]较大，则让j指向右孩子，否则j不变。总之j指向i的最大孩子
- 若最大孩子的值比双亲R\[i]大，则将较大孩子移到双亲的位置。这个过程可能破坏以R[j]为子树的堆性质，所以继续筛选R\[j]的子树
- 若最大的孩子R\[j]比双亲R\[i]小，则说明根节点已经最大，满足堆性质，退出循环
- 将temp放在R\[i]的位置，即把原根节点放在最终位置

~~~c++
void siftDown(vector<int>&R,int low,int high)
{
    int i=low;
    int j=2*low+1;//左子树
    int temp=R[low];
    while(j<=high)
    {
        if(j<high&&R[j+1]>R[j])//如果右孩子更大
            j++;
        if(temp<R[j])
        {
            swap(R[i],R[j]);//将孩子结点的值放到双亲结点,可能改变子树大根堆的性质，所以要继续循环进行筛选
            i=j;
            j=2*i+1;//继续向下筛选
        }
        else
            break;
    }
    R[i]=temp;//原结点放到最终位置
}

//堆排序算法
//先建立初始堆，根节点一定是最大关键字，将根节点放在排序序列最后，即堆中根节点和最后一个叶子节点交换
//然后剩下的堆中，因为左右子树满足堆的性质，所以再做一次堆筛选就可以使整棵二叉树成为大根堆
//重复此过程直到完全二叉树只剩下一个结点为止
void HeapSort(vector<int>&R)
{
    for(int i=n/2-1;i>=0;i--)
    {
        siftDown(R,i,n-1);//从最后一个分支节点开始建立初始堆
    }
    for(int i=n-1;i>0;i--)
    {
        swap(R[0],R[i]);
        siftDown(R,0,i-1);//对无序区R[0...i-1]继续筛选
    }
}
~~~

- 分析

  - 自顶向下建堆：O（n）
  - 自底向上：O（$nlog_2n$）
  - 最好和最坏时间均为O（$nlog_2n$）
  - 空间复杂度：O（1）
  - 不稳定

#### 堆数据结构

- 插入

先插入到末尾，再向上筛选

O（$log_2n$）

- 删除

堆只能删除非空堆的堆顶元素，即最大元素

用堆中末尾元素覆盖堆顶元素，元素个数-1，采用向下筛选方法调整为堆

O($log_2n$)

- 取堆顶

返回R\[0]

## 归并排序

- 二路归并

把序列中每个元素先看成一个有序区，相邻的有序区使用二路归并进行合并，不断重复直到有序

- 算法分析

$O(log_2n)$

空间复杂度$O(n)$​

稳定

## 基数排序

最好最坏平均都是$O(d(n+r))$

空间复杂度$O(r)$

变量解释：

- d：共做d趟分配和收集，与最高位数有关
- n：元素的个数
- r：进制，如二进制2.，十进制10
![[Pasted image 20240622224326.png]]