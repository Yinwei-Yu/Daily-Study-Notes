**Index Building**

  The index building process is primarily handled by the IndexNode component. Here's a step-by-step explanation:

   1. **Request Initiation:** The process starts when the IndexCoord (a central coordinator for indexing) sends a CreateJobRequest to an IndexNode. This request contains all the necessary information for building an index,

      including:

       * BuildID: A unique identifier for the index build task.

       * CollectionID, PartitionID, SegmentID: Information about the data segment to be indexed.

       * DataPaths: The paths to the raw data files (binlogs) in object storage.

       * IndexParams, TypeParams: Parameters specifying the index type (e.g., HNSW, IVF_FLAT) and its configuration.

       * StorageConfig: Configuration for accessing the object storage.


   2. **Task Creation:** The IndexNode receives the request and creates an indexBuildTask. This task encapsulates all the

      information and logic required to build the index.

   3. **Task Scheduling:** The indexBuildTask is then enqueued into a TaskScheduler within the IndexNode. The scheduler

      manages a pool of worker goroutines to execute the tasks.


   4. **Pre-execution:** Before the actual index building begins, the PreExecute method of the indexBuildTask is called.

      This method performs some setup, including:

       * Parsing and validating the index parameters.

       * If necessary, reading the binlog files to get metadata about the field to be indexed (e.g., data type, field

         ID).

   5. **Index Construction (C++ Core):** The core of the index building process happens in the Execute method. This

      method calls the C++ indexing engine via CGO using the indexcgowrapper.CreateIndex function. This function

      takes a BuildIndexInfo struct, which contains all the necessary parameters, and passes it to the C++ code. The

      C++ code then:

       * Reads the raw data from the specified data paths.

       * Builds the index in memory according to the specified index type and parameters. This is a computationally

         intensive process.

       * For disk-based indexes like DiskANN, it calculates the required disk space and configures the build

         parameters accordingly.

   6. **Post-execution (Uploading the Index):** After the index is built in memory, the PostExecute method is called.

      This method is responsible for:

       * **Serializing and Uploading:** The in-memory index is serialized into one or more index files. These files are

         then uploaded to the object storage.

       * **Updating Metadata:** The paths to the newly created index files, along with some statistics (e.g., serialized

         size, memory size), are stored in the IndexNode. This information is then sent back to the IndexCoord, which

          updates the central metadata store (etcd).

       * **Cleanup:** The in-memory index and any temporary local data are cleaned up.