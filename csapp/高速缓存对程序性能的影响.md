
# 存储器山

一个程序从存储系统中读数据的速率称为读吞吐量(read throughput),或者称为读带宽(read bandwidth)

书上通过一个程序从一个紧密程序循环中发出一系列的读请求,测量读吞吐量来看存储系统的性能:

[[深入理解计算机系统 .pdf#page=480&selection=58,9,58,11|深入理解计算机系统 , 页面 480]]

结果表明,如果以不同的工作集大小和步长来运行这个函数,会得到一个关于读带宽的时间和空间局部性的二维函数,称为[[深入理解计算机系统 .pdf#page=481&selection=97,1,97,5|存储器山]]

其中空间局部性可以弥补时间局部性不足带来的性能损失

总结来说,应该编写空间和时间局部性都良好的代码

# 重新排列循环来提高空间局部性


考虑矩阵相乘问题:

![[Pasted image 20240816183441.png]]

通常两个矩阵乘法通过三个嵌套循环实现,若改变三个循环的次序,也可以计算出相同的结果,因此一共有六个不同的版本:

![[Pasted image 20240816184520.png]]

对于每个版本，我们可以得到不同的缓存命中率：
详见:
[[12-cache-memories.pdf]]
的29-35页

下面对kij版本解释一下:

![[Pasted image 20240816184846.png]]

这种版本和ikj版本的性能相同,本质都是采取了另一种算法思路:
常规的矩阵乘法是按照公式一步步来的
比如假设A,B是两个$2*2$矩阵,
则:

$c_{00}=a_{00}*b_{00}+a_{01}*b_{10}$
$c_{01}=a_{00}*b_{01}+a_{01}*b_{11}$
$c_{10}=a_{10}*b_{00}+a_{11}*b_{10}$
$c_{11}=a_{10}*b_{01}+a_{11}*b_{11}$

常规思路是按照公式算一行,
但是kij的思路是下图所示:

![[3f2922d94c0538e1b97f63d411bc425f.jpg]]

从pdf中可见,这样对B和C的访问都对缓存有着0.25的不命中率,十分高效

---

在利用空间局部性之外,还可以利用分块(block)来提高时间局部性
[[深入理解计算机系统 .pdf#page=486&selection=77,0,77,12|深入理解计算机系统 , 页面 486]]
类似于在矩阵乘法里进行分块矩阵相乘,使每个块的大小可以放进缓存中
