
![[Pasted image 20240816162303.png]]

下面假设系统有一个cpu,一个寄存器文件,一个L1高速缓存和一个主存,当cpu执行一条读内存字w的指令,它向L1高速缓存请求这个字(==即向缓存发送这个字的地址==),高速缓存确定一个请求是否命中然后抽取出被请求的字的过程分为三步:

1. 组选择
2. 行匹配
3. 字抽取

## 组选择

高速缓存从w的地址中取出s个组索引位,解释为一个无符号整数,,然后匹配到相应的组号

**可以将高速缓存看作一个关于组的一维数组**

## 行匹配

在直接映射高速缓存中,因为每组只有一行,所以当且仅当设置了有效位,而且高速缓存行中的标记与w的地址中的标记相匹配时,这一行中包括w的一个副本

![[Pasted image 20240816163414.png]]

## 字选择

一旦命中后,根据b个块偏移位,将块看成一个字节的数组,字节偏移是到这个数组的一个索引,eg.上图中快偏移是从块中字节100=4处开始的

## 直接映射高速缓存中不命中时的行替换

从下一层中取出被请求的块,然后将新的块存储在组索引位指示的组中的一个高速缓存行中.

这里会连续地取出从目的地址开始的一系列字节的数据,假设缓存行大小为 64 字节，如果一个内存地址为 `0x1000` 的数据块被加载到缓存中，则从 `0x1000` 开始的 64 字节的数据都会被加载到同一个缓存行中

## 示例

$(S,E,B,m)=(4,1,2,4)$

![[Pasted image 20240816165734.png]]

- 这里的块号是人工加的,实际并不存在,块号由标记位和索引位一同确定
- 多个块可能映射到同一个内存组
- 映射到同一个高速缓存组的块由标记为唯一地标识

下面是模拟cpu读取数据的过程:

刚开始高速缓存是空的(每个缓存位都是0)

![[Pasted image 20240816165924.png]]

1. 读地址0000的字,对应组0,因为缓存是空的,这时发生冷不命中,缓存从主存中取出$m[0]$和$m[1]$两个数据,分别放在块0和1中,然后返回块0的数据给cpu,这使得缓存的内容变成这样:

![[Pasted image 20240816170148.png]]

2. 读地址0001的字,这次高速缓存命中,直接返回块1的内容,缓存内容不变
3. 读地址1101的字,发生冷不命中,高速缓存将$m[12]$和$m[13]$加载到组2中,返回相应数据,这时内存内容是:

![[Pasted image 20240816170418.png]]

4. 读地址为1000的字,发生冲突不命中

![[Pasted image 20240816170443.png]]

5. 读地址为0000的字,发生冲突不命中

这里体现了冲突不命中,即我们有足够的高速缓存空间,却交替的引用映射到同一个组的块

下面是**高速缓存冲突不命中的具体实例**:
[[深入理解计算机系统 .pdf#page=467&selection=39,0,39,15|直接映射高速缓存中的冲突不命中]]

*注意其中的一个术语 抖动 (thrash)
[[深入理解计算机系统 .pdf#page=467&selection=353,4,354,8|深入理解计算机系统 , 页面 467]]*

在最后还有一个问题:为什么高速缓存用地址中间位做组索引而不是高位,原因如下:

![[Pasted image 20240816171212.png]]

如果用高位做索引,那么一些连续的内存块会被映射到一个组,比如左图中每连续四个块在一个组中,这导致对于一个有着良好空间局部性的程序来说,每次顺序扫描数组的元素,缓存中只有一个块大小是有效的,这造成了缓存的浪费
