# 操作系统概念

## 绪论

![](附件/第1章%20导论.ppt)
![](附件/第1章%20补.pptx)

硬件 系统 程序 用户
应用程序不可直接接触硬件（cpu和内存之外,为什么?

1. 维持秩序
2. 硬件型号多,应用开发困难

几个问题

1. 怎么限制应用程序访问硬件
2. 硬件型号多样,应用程序不可能穷尽该咋整
3. 键鼠操作经过操作系统最后如何触发

计算机启动过程:
软中断:是一个指令----系统调用

操作系统管理：

1. 处理机
2. 存储器
3. 设备(外围设备
4. 文件

### 历史

人工操作
早期批处理:1.联机批处理2.脱机批处理
监督程序
单道程序系统
多道程序设计技术

### 作业

所做工作的集合
针对于计算任务
作业调度->谁从硬盘进内存
进程调度->谁从内存进cpu

### 分时系统

共享主机
原理:把时间划分为很短的时间片,轮流按时间片把处理机分配给各个联机作业使用

### 三种操作系统类型

批处理
分时
实时:针对特定场合专用系统,在规定时间内完成对特定事件的处理

### 分布式系统

在某个特定任务上,多台计算机协同工作,共同完成任务
每台计算机都有自己的操作系统,经网络连接

### 基本特征

并发
共享
虚拟
不确定:异步性

### 双重操作模式(如何限制app访问硬件)

需要两种操作模式:用户模式和内核模式
在硬件中增加模式位表示当前模式:1用户模式,0内核模式
内核->用户:硬件修改
用户->内核:发生中断就切换为内核模式
内存被划分不同区域,用户程序不能访问内核区域
32位系统:win 用户2G,内核2G linux 用户3G,内核1G

> 编译器保证用户程序不会访问内核区域
> 要是写汇编写程序,就要自己保证

### 资源管理

进程管理
存储管理:内存保护问题,应用不活跃的部分能否从内存中移除?
设备管理:操作系统怎么向下解决多样的硬件?--通用驱动接口(系统和驱动程序交互),特定硬件设备驱动程序(硬件厂商提供)
文件管理

## 操作系统结构

### 用户接口(交互式)

命令行接口:内部命令外部命令
图形用户接口

### 系统调用

程序和系统之间参数传递:

1. 寄存器参数传递
2. 参数存在内存的一张表中,表地址作为寄存器的参数传递
3. 程序把参数压入栈,操作系统弹出

堆栈的详细解释:
用户程序和操作系统各有各的栈,用户程序把参数压入用户栈,系统调用通过软中断

用户态有一套API封装了系统调用,用户程序调用API,API调用系统调用
win32 api
posix api

### 结构

内核结构有三种：

1. 模块结构
2. 层次结构
3. 微内核结构

#### 分层方法

操作系统分层,每一层提供一组功能,上层调用下层
底层为0层硬件层，最上面为用户接口

就图一乐🤣

现代操作系统按功能划分,可能每个功能内部有层次结构

#### 微内核

所有非基本部分从内核中移走,实现为系统程序或用户程序
(执行与决策分离,决策被分离出去)
微内核包括最小的进程和内存管理以及通信功能

内存管理,设备管理,文件管理等高级服务功能从内核中分离出来,成为独立的非内核模块,相互之间调用需要系统调用

降低了开发难度但是效率较低

## 进程管理

前趋图:进程之间的依赖关系

### Bernstein 条件

不能同时写,不能一读一写,可以同时读

### 进程

定义:
程序在一个数据集合上的一次执行过程

进程与程序的关系:

1. 程序是静态的,进程是动态的,程序是指令和数据的集合,进程是程序的一次执行
2. 进程是暂时的,程序是永久的
3. 进程与程序的组成不同,进程包括程序,数据,进程控制块
4. 一个程序可以对应多个进程,一个进程可以包括多个程序(动态链接库)
5. 进程可以创建新进程,程序不能创建新程序

#### 进程的状态

1. 新建态
2. 运行:正在cpu上执行
3. 等待:阻塞睡眠状态,由于某个事件而暂时无法执行下去(等待IO等),通过执行系统调用进入
4. 就绪:获得了所需资源,等待cpu调度
5. 终止

挂起(静止)状态:

1. 系统故障或功能受到破坏,先挂起进程,修复后再恢复
2. 检查中间结果,挂起进程以便检查(调试)
3. 资源不足,挂起进程以腾出资源
4. 内存不足,在外存挂起

#### 进程控制块 process control block pcb

记录进程信息的c语言结构体

{
  pointer //链表指针
  process state//进程状态
  process number//进程号
  pc
  registers
  memory limits//内存限制
  list of open files
  ...
}

#### 就绪队列

每个cpu都有自己的就绪队列
不同的进程状态可以有不同的队列,如就绪队列,等待队列等
