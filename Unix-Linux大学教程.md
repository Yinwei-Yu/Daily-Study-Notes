[[Unix  Linux大学教程 (哈恩) (Z-Library).pdf]]

linux命令手册：

[在线](https://www.linuxcool.com/)

[离线](D:\study\linux参考手册\index.html)

# 零碎知识&命令

unix是一个多用户操作系统

unix=内核+实用工具

修改密码：passwd

last [username]:

显示用户上次或最近几次的登陆时间

---

运行级别:

| 0    | 关机               |
| ---- | ------------------ |
| 1    | 单用户模式(命令行) |
| 2    | 非标准化           |
| 3    | 多用户模式:命令行  |
| 4    | 非标准化           |
| 5    | 多用户模式:GUI     |
| 6    | 重新启动           |

---

> 使用 su  口令并输入密码成为超级用户

---

关机：shutdown [now] [time]

重启:reboot

init命令用于重新设置启动级别

> 需要sudo权限

---



dmesg

显示系统启动与关闭时的信息



---



^M 和 回车发送CR信号 ---返回信号

^J 发送LF信号---换行信号

- 可以认为是相同的

总结:

1. 返回字符=^M
2. 换行字符=新行字符=^J
3. 一般而言,每行文本必须以一个新行字符结束
4. 按下回车,发送一个返回字符,unix自动将返回字符变为新行字符
5. 终端上显示数据,每行必须是"返回+新行"结束



---



<^J>**stty sane**<^J> 

<^J> **reset** <^J> 

 复原终端



# 可立即使用的程序

## which type
查找程序位于什么位置，type的输出信息更加详细，type为终端内置程序

## 停止程序的三种方法

CTRL+D：告诉程序当前输入已经结束

CTRL+C：发送intr信号

quit

## date 

date查看当地时间

date -u 显示格林威治时间

## cal
显示日历

cal显示当月

cal 2024 显示某一年

cal 12 2024 显示某年某月

- 显示某月日期必须加上年份

cal -j 12 2024 ： 显示某天是这一年的第几天

## 系统信息 uptime hostname uname

- uptime 显示系统已经运行了多久
users：用户个数
load average 前1 5 15 分钟等待执行的程序的数量

- hostname
计算机名称
- uname
操作系统名称
uname -a 显示详细信息

## 自己信息 whoami quota
whoami显示当前用户

## 其他用户信息 user who w

users 登录系统的用户的名称

who：谁在哪个终端上什么时间从哪里登录

w：用户，终端，来源 登陆时间 自上次键入空闲时间 登陆后所有进程使用的cpu时间 当前进程使用的cpu时间 在做什么

w mirai 指定名称查看某个用户的具体情况

## 离开提醒

leave 提醒还有多久该离开

leave 1344 =》 13：44

leave +15 =》15分钟后离开

- 若输入的时间小于等于12，则默认时间为接下来12小时之内的时间

## 内置计算器 bc

bc -l 使用bc自带的数学库启动


支持正常优先级运算


小数点精度scale=

- -l启动scale默认为20


bc中可使用变量，只能用小写字母，且不能组合


ibase ：输入基

obase：输出基

使用ABCDEF永远代表对应十进制数字



## dc计算器——基于逆波兰表达式


# 文档查询

## man

less使用

backspace b g G / ？ n N


## 手册组织方式


| 1    | 命令     |
| ---- | -------- |
| 2    | 系统调用 |
| 3    | 库函数   |
| 4    | 特殊文件 |
| 5    | 文件格式 |
| 6    | 游戏     |
| 7    | 杂项信息 |
| 8    | 系统管理 |

手册分为8节，每节对应内容如上


## man中指定节号

```
man 1 kill

```

## whatis

显示命令的描述



## apropos

在name节中搜索包含特定关键字的命令



## info

树结构

快捷命令



# 命令行语法



## 一次输入多个命令

使用';'隔开命令即可



## 命令语法



```
命令名称 选项 参数
```

---

选项:

选项可以结合在一起

单个连字符跟单个字母

双连字符跟全拼

---

注意:

选项须在参数之前

一个或多个

零个或多个(留意默认值)

---

==语法==

学好一个命令的三个问题

- 命令是做什么的
- 如何使用选项
- 如何使用参数

**命令语法规则**

1. 方括号中的项是可选的
2. 不在方括号中的项是必选项
3. 黑体字必须按原样准确输入
4. 斜体字可以用适当值替代
5. 后面接省略号代表参数可重复多次

---

更复杂的规则

6. 如果一个单独的选项和一个参数组合在一起,那么该选项和参数必须同时使用

```bash
man [-P pager] [-S sectionlist] name...
```



7. 由竖线(|)分开的两个或多个项表示可以从列表中选择一个项

eg.

```
who ... [file  | arg1 arg2]
```

表示可以提供一个文件或者两个名为arg1 arg2 的参数

## man手册 

通常把选项用options代替



# shell



## shell介绍

bourne shell

c-shell

临时改变shell

永久改变shell



## 变量和选项



### 交互式和非交互式shell

交互式即由人输入和显示给人看

非交互式即执行脚本的shell

### 环境 进程 变量

- 环境:

一组用来存放信息的变量

- 变量:

存储数据的实体,变量名和值

- - TERM变量存储所使用的终端类型

由shell启动的程序,父进程和子进程

子进程继承父进程的一切环境



### 环境变量和shell变量

**局部变量 全局变量**

- 局部(shell)变量

1. 存放对shell本身有意义的信息,如ignoreeof选项确定是否忽略eof信号
2. 在shell脚本中以普通程序中局部变量的方式使用

---

变量存在的问题:

有的变量同时有局部变量和全局变量的含义

- bash

将变量只定义为局部变量或者同时定义为局部变量和全局变量

*不能有变量只是全局而不是局部*

创建变量时变量自动被设置为shell变量

可以使用==export==命令将变量变成环境变量

```bash
1.
	SPORT=surfing # 注意等号左右两边没有空格
	export SPORT
2. 
	export SPORT=surfing
```



### 显示环境变量 env printenv

env显示默认变量

printenv同样



可以使用管道和sort进行按字母表排序



### 显示shell变量 set

set显示shell变量以及他们的值



### 显示以及使用变量的值 echo print

```bash
echo i love you

echo $TERM

echo 'my name is <$USER>'

echo $USER $TERM $PATH

echo "My favorite sport is ${ACTIVITY}ing" #花括号保证和周围不分开


```



### Bourne shell export unset

```bash
export NAME[=value]...
```

- 删除变量

unset

**称为复位变量**



### shell选项 set -o set +o

```bash
#设置一个选项
set -o option
# 复位一个选项
set +o option

```



### 显示shell选项

```bash
set -o#人类阅读友好 
set +o#脚本友好
```



## 命令和定制

### 元字符

![image-20240805170058015](C:\Users\32284\AppData\Roaming\Typora\typora-user-images\image-20240805170058015.png)



### 引用和转义



按照字面解释元字符:

反斜线,单引号,双引号

---

\

转义字符

改变的是元字符的模式



---

''

单引号

强引用

单引号中的所有字符都按照字面解释

---

""

双引号

弱引用

保留$ ` \ 的特殊含义



---



### 强引用和弱引用

- 强引用

\ 的引用是最强的

可以引用新行字符

\return 将会开启新的一行,但不表示结束(即不具有新行的含义)

eg.

~~~bash
echo this is a long \
long sentence that is \
need to type a long time.

~~~

---

- 单引号

需要一对儿来标记结束

bash家族shell会等待输入第二个引号

c-shell家族会输出错误



### shell内置命令 type

使用

``` type commandname``` 查看命令是否是内部命令



---

搜索shell手册中的builtin来学习内部命令



使用```help -s command``` 来查看命令的语法



### 外部命令以及搜索路径

shell在PATH环境变量中查找外部命令



### 修改搜索路径

使用export命令使PATH成为环境变量

```bash
export PATH="/bin:/usr/bin:usr/ucb:/usr/local/bin"
```

各个名称之间使用冒号隔开,等号两边无空格

该命令应置于登陆文件中

----

也可以添加自己的目录

```shell
export PATH="$PATH:$HOME/bin"
```

- 尽量将自己设置的目录放在系统原有设置目录之后,否则容易覆盖系统目录



### shell提示

使用```export PS1="$ "``` 来设置提示符

---

可综合使用变量的值

eg.

$USDER 

$PWD

下面列出了常用环境变量:

![image-20240805172306568](C:\Users\32284\AppData\Roaming\Typora\typora-user-images\image-20240805172306568.png)

### 引用变量时使用的引号

变量有变化使用单引号

变量不变化使用双引号

eg.

```bash
export PS1='Your lucky number is ${RANDOM} $ '
export PS1="${USER}"
```

第一条里$ 符号保留为\$符号,在使用这个变量时才会解释为元字符

第二条里 直接被解释为元字符,对变量进行展开



### 转义字符的特殊码

![image-20240805172910768](C:\Users\32284\AppData\Roaming\Typora\typora-user-images\image-20240805172910768.png)

### 命令替换

允许在一条命令中嵌入另一个命令

```bash
echo "The time and date are `date`."
```

先运行date命令,在将date命令的结果嵌入到echo命令中传递给echo命令

- ==date两边是反引号!!!!!!==

---

basename可以抽取任何路径名的最后一个部分

---



### 键盘输入删除快捷操作

^W删除刚才输入的一个单词

\^U或\^X删除整行

使用stty显示系统上所有的键映射

^D删除光标后的一个字符



### 历史列表fc history

使用上下箭头查看一条历史命令

每一个命令在历史列表中称为事件

---

fc -l

history

都可以显示历史列表

---

fc -s num

! num

使用编号为num的命令

---

fc -s

!!

使用上一条命令

---

fc -s pattern=replacement number

pattern和replacement都是字符串 number是事件编号

eg.

**25 vi temp**

**fc -s temp=data 25**

---

也可以修改某一部分

eg.

```bash
datq
fc -s q=e
```



### 设置历史记录大小

```bash
export HISTSIZE=50
```



- 养成先查看文件再删除文件的习惯

> 使用ls和rm结合,用历史替换进行快速操作



### 自动补全

bash支持:

1. 文件名和目录名
2. 命令
3. 变量
4. 用户标识
5. 主机名(联网)

- 连续按tab键会显示出所有匹配的选项



### 别名 alias

```bash
alias [name=commands]
```

等号两边不能有空格

commands包含一个或多个命令,看情况使用引号

使用```unalias``` 移除别名

---

使用```\ls``` 临时挂起别名

### 别名示例,避免删除文件

```bash
ls temp*
fc -s ls=rm
alias del 'rm \!ls:*'

```

### 从历史列表中重用命令

```bash
alias h=history

alias r="fc -s"
# this is a example
vi tempfile
r tempfile=data
 
#gei a alias to alias it self
alias a=alias

```

 ## 初始化文件



初始化文件:

登陆文件

环境文件



---



### 点文件和rc文件

点文件是隐藏文件

使用ls -a查看所有文件

环境文件以rc结尾,意为:running command



### 执行初始化文件的时机

登录shell执行登陆文件和环境文件

非登录shell执行环境文件

- bash的登录shell只执行登录文件而不执行环境文件

### 脚本注释

shell使用#作为注释标志



# 重定向和管道

unix设计准则:

> 除非程序可以更小,否则小就是完美的

学习新程序应问的三个问题::

1. 可以干什么
2. 有什么基本细节
3. 在什么地方可以查询到帮助

## 标准输入,输出,标准错误

stdin

stdout

stderr

---



重定向标准输入输出:

*command*   <  *path/file*

\> *path/file*

---



## 重定向

\> 覆盖

\>> 追加

使用set -o noclobber 选项禁用>

必要时可以用>|恢复其作用



## 文件描述符,重定向标准错误

**文件描述符**

每个输入源和每个输出目标由一个唯一的数字标识,称为==文件描述符==

---

**默认文件描述符**

0:标准输入

1:标准输出

2:标准错误



因此重定向标准输入的语法如下:

```commond 0< inputfile ```

其余类似

0,1是默认选项

---

可以使用多个重定向

eg.

```bash
sort < file1 >output 2>errors
```



## 子shell

首先理解子进程和父进程



在终端中输入bash或tsh后,父进程启动一个新的shell,新的shell就是子shell

子shell继承父shell的环境,且不会改变父进程的环境

可以新建子shell并使用命令等

也可以:

```(date)```

使用'()'来在子shell中使用命令



## 组合标准输出和错误

基本思想是 将一种类型的输出重定向到一个文件,再将另一种类型的输出重定向到同一个位置.

```commond x > outputfile y>&x```

---

也可以使用 >&或&>来直接重定向标准输出和错误输出



## 抛弃输出

将输出重定向至 /dev/null即可

/dev/null被称为位桶'bit bucket'



## 管道

|

前者的标准输出作为后者的标准输入

---

管道线分流 tee

tee从标准输入读取数据,并向文件和标准输出个发送一份



tee默认重写文件,若要追加需要加上-a选项



## 条件执行



commond1 && commond2

1成功时才执行2

commond1 || commond2

1失败时才执行2

---





# 过滤器

## 简单的过滤器

cat

将标准输入的数据复制到标准输出

---

应用

1. cat > data

快速创建一个小文件

2. cat >> data

在已有文件末尾追加几行

3. 显示短文件
4. 显示文件的最后一部分

5. 通过重定向标准输入和标准输出复制文件
6. 将几个文件合并

## 过滤器列表

![image-20240807180727789](C:\Users\32284\AppData\Roaming\Typora\typora-user-images\image-20240807180727789.png)

![image-20240807180746289](C:\Users\32284\AppData\Roaming\Typora\typora-user-images\image-20240807180746289.png)

## cat

[cat](D:/study/linux参考手册/c/cat.html)(还是尽量先看man手册吧...中文手册错误太多了)

组合文件

- 不要将输出重定向到一个输入文件上

shell处理重定向的方式:

​	如果文件不存在,则shell创建这个文件;否则shell清除这个文件并写入

-n 每行前加上行号

-b忽略空白行,并加上行号

-s将多个连续的空白行替换为一个空白行



## 划分文件 split

默认每个文件1000行

-l 选项改变行数

默认创建的文件名:

以x开头,之后跟两个字母后缀,默认允许26x26=676个文件

---

改变文件名:

-d 以数字作为后缀

也可以在最后加上自己希望的文件名前缀

可以使用-a选项指定后缀的数字或者字符的数量



## 反转文本行 tac

是cat的反写(乐)

将文件的各行反转



## 反转字符 rev

将各行中的字符反转



## head tail

从头尾提取数据

使用-n 选项指定需要提取的行数



## 删除数据列 colrm

```bash
colrm [startcol [endcol] ]
```

删除从start到end的所有数据

没有指定end就默认结尾



# 过滤器:比较和抽取



## 比较文件

![image-20240807183459474](C:\Users\32284\AppData\Roaming\Typora\typora-user-images\image-20240807183459474.png)

## cmp 比较任意两个文件

只有一种使用情形:查看两个文件是否相同

相同不返回任何值,否则返回信息

cmp按照字节顺序比较,所以可以比较任何类型的文件



## comm 比较有序文本文件

逐行比较文本文件

以三列输出:

只在第一个文件里有的 | 只在第二个文件里有的 | 两个文件里都有的



可以使用-123 分别抑制某一列的输出



## 比较两个无序文本文件 diff

记住输出:

c:change1

d:delete 通常可以忽略后面的数字

a:append



eg. 1c3:

第一个文件的第一行改变成第二个文件的第三行

---

sdiff

和diff -y选项一样



## 抽取数据列 cut

抽取指定列并将其他列删除

与colrm相反

cut -c list file...

list为需要抽取的列

可以使用逗号将行号隔开

---

抽取数据字段

1,2,3

4,5,6

7,8,9

上面三行每行称为一个记录

每行的各个部分成称为字段

充当字段分隔符的是定界符

cut -f1-5 -d',' file

## 组合数据列 paste

RTFM



# 过滤器:统计和格式化

## 创建行号 nl

-v 起始号

-i 增量

默认nl不对空行编号 -b a 对所有编号

-n ln左对齐没有前导0 rn右对齐没有前导0 rz右对齐有前导0



## 统计行 单词 字符数量 wc

wc -c l L w

c 字符

l行

w 单词

L最大行的长度



## unix使用制表符的方式

默认在1,9,17位置

制表符默认宽8个字符

---

对于vim使用

:set list

可视化制表符



## 将制表符转化为空格 expand

-t 制表符位置

-i 只在开头转换



## 空格转化为制表符 unexpand

与expand逆



## 格式化行 fold

-w 新行的最大宽度

-s 不分割单词



## 格式化段落 fmt



## 按页格式化文本pr

也可用于按列格式化文本



# 过滤器:选取 排序 组合 变换



## grep

-c(count) 统计所抽取的行的数量

-i 比较时忽略大小写

-n 在每一行前面加上行号

-l 显示包含该模式的文件

-L 显示不包含指定模式的文件

-w 只搜索完整的单词

-v 选取不包含指定模式的行

-x 完全由搜索模式构成的行

-r 递归搜索目录树

---

egrep 

grep 的升级版本,允许拓展正则表达式



## 选取以特定模式开始的行 look

文件需要以字母顺序排序

look必须从一个或多个文件中获取输入

- 优点

简单且速度快

---

查找以特定模式开始的单词

look *pattern*

---

aspell -c file 

-c 检查文件中单词的拼写

## 排序数据 sort

不允许将内容重定向保存到原文件中

可以使用-o选项完成该任务

---

-d 只查看字母 数字 空白符,忽略标点符号

-f(fold) 同等对待大小写字母

-n 识别行开头或字段开头的数字并按数字进行排序

-r 反向排序

-u 查找相同的行并且将相同的行只留下一行

-c 检查是否有序 有序不返回任何值 否则返回错误信息 :第几行 什么数据处



## 查找重复行 uniq

- 消除重复行
- 选取重复行
- 选取唯一行
- 统计重复行的数量

默认将重复行只留下一行

-d 只查看重复行

-u 只查看唯一行

-c 统计每行出现的次数



## 合并两个文件的有序数据

基于两个文件中的共同值合并数据

自动忽略前导空白符

---

若两个文件中有信息缺失,eg.

**birthday**

A	2004/11/07

B	2005/05/11

**gift**

A	none

C	black monkey

上面两个文件中 birthday中没有C,但是gift中有C

对B同理

这时使用join,默认情况只会链接匹配的链接字段

-a1 输出第一个文件的信息 即便在第二文件中缺失匹配

-a2 输出第二个文件的信息 即便在第一个文件中确实匹配

-a1 -a2 都包含



---



常规使用join(不加-a):内联接

加-a 选项: 外联接



---

-v 查看不匹配的行

-i 忽略大小写字母

可以选择字段进行连接

eg.

```join -1 3 -2 4 data statistics```



## 偏序创建全序(完成拓扑排序)tsort

输入的每一行都包含一对由空白符隔开的字符串

每一对字符串都代表一个偏序

eg.

a b 

b c 

意为:a依赖b,b依赖c

若有循环存在则报错



## 在二进制文件中搜索字符串 strings

[strings](https://man.niaoge.com/strings)



## 转换字符:tr

对字符执行三种不同运算

1. 将字符变为其他字符

2. 将连续出现的字符替换为一个单独的字符
3. 删除指定的字符

``` bash
tr a A < old

tr abc ABC < old

tr abcde Ax < old 
tr accde Axxxx < old

tr ':;?' \. <old >new

tr A-Z a-z < old > new

tr 0-9 A-z < old > new

#预定义字符类
[:lower:] [:uppre:] [:digit:]
```



---



**用于转换不可见字符**

unix使用^J 标记末尾

windows用\^M^J标记末尾

mac用^M 标记末尾



![image-20240807214226354](C:\Users\32284\AppData\Roaming\Typora\typora-user-images\image-20240807214226354.png)

eg.

```bash
tr '\r' '\n' < mac > unix
# 其余类似
```

---



-s(挤压) 将符合的模式均替换成一个指定字符



-d 删除指定的字符



-c(complement,补集) 匹配所有不在第一组内的字符



## 非交互式文本编辑 sed

```sed [-i] command | -e command... [file...]```

**sed读取数据流的过程**

1. 从输入流中读取一行
2. 执行指定的命令 对该行进行必要的转换
3. 将该行写入输出流中

-i 改变原始文件 sed自动生成一个临时文件 

---

使用

**替换**

命令为s

```[/address|pattern/]s/search/replacement/[g]```

address是输入流中的一个或多个地址

pattern是一个字符串

search是正则表达式

replacement是替换文本

g后缀标志替换所有匹配字符串(默认只匹配第一个)

---

**只对指定行进行操作**

`number[,number] | /regex/`



最简单的地址就是一个单独的行号



```bash
sed '5s/miku/MIKU/g' names

# 指定行的范围可以使用逗号将行号分开
sed '5,10s/miku/MIKU/g' names

# 使用$符指定数据流最后一行
sed '5,$s/miku/MIKU/g' names

# 只改变包含两个连续数字的行
sed '/[0-9][0-9]/s/miku/MIKU/g' names
```



---



连续使用多个sed命令时可以使用-e选项 最后用 **\\** 转义换行符



# 正则表达式



## 适用语法



| 元字符  | 含义 |
| ------- | ---- |
| .       | 除换行外,匹配任意单个字符 |
| ^       | 锚,匹配行的开头 |
| $       | 锚,匹配行的结尾 |
| \\<     | 锚,匹配单词开头 |
| \\>     | 锚,匹配单词结尾 |
| [list]  | 匹配列表中中的任意字符 |
| [^list] | 匹配不在列表中的任意字符 |
| ()      | 组:视为一个单独的单元 |
| \|      | 交变,匹配选择之一 |
| \ | 引用,从表面解释字符 |



| 运算符 | 含义             |
| ------ | ---------------- |
| *      | 匹配0次或多次    |
| +      | 匹配一次或多次   |
| ?      | 匹配0次或一次    |
| {n}    | 匹配n次          |
| {n,}   | 限定,最少匹配n次 |
| {0,m}  | 限定,最多匹配m次 |
| {,m}   | 同上             |
| {n,m}  | 最少n次,最多m次  |



| 类        | 含义         | 类似于    |
| --------- | ------------ | --------- |
| [:lower:] | 小写字母     | a-z       |
| [:upper:] | 大写字母     | A-Z       |
| [:alpha:] | 字母         | A-Za-z    |
| [:alnum:] | 字母和数字   | A-Za-z0-9 |
| [:digit:] | 数字         | 0-9       |
| [:punct:] | 标点符号     | -         |
| [:blank:] | 空格或制表符 | -         |

> 正则表达式起源于计算机科学，指的是一组指定模式的规则



## 基本和扩展正则表达式

现代版本:扩展正则表达式 ERE

以前:基本正则表达式 BRE

> sed和grep只支持基本正则表达式

区别:

基本正则表达式:

1. 不能使用元字符:`? + |`

2. 必须转义的元字符: `() {}`
3. 不能使用预定义字符类



## 基本规则

字母和数字都与自身匹配

锚:^ 搜索以特定模式开头的行

锚:$搜索以特定模式结尾的行

> ^和$可以在同一个正则表达式中组合使用,只要描述的情形有意义即可,可以用 \^ nihao \$ 匹配整行只有一个单词的

\\<abc abc只能出现在单词开头

\\> abc abc只能出现在单词结尾

> 同时使用即可匹配一个单词

> 可以用\b替代\>和\<

\b代表 boundary marker

- 注意单词的定义:由字母,数字,下划线组成的连续字符序列

## 字符类和预定义字符类

`grep H[aA] data`

其中aA就是一个字符类

- 字符类不包括方括号

---



**预定义字符类的方括号实际上是名称的一部分**

 `grep '21[[:alpha:]] data'`

搜索21后接着字母的所有行

- 注意这里有两个方括号,外面的表示这是一个字符类,里面的方括号是预定义字符类的一部分

---

需要匹配不在特定字符类之中的字符,只需在开头左方括号之后再放一个^即可

`grep 'X[^ao]' data`

查找X后不跟a或o的行



## 重复运算符

eg.

`grep 'H[a-z]*' data`

 常用组合:使用一个.后加*来匹配任何字符的0次或多次出现

`grep '\b[0-9]{2,3}\b' data`

查找有两个或三个数字的行



---



也可以对多个字符使用重复运算符,这样的模式称为组

创建组可以将一串字符视为一个单元

xyzxyzxyzxyzxyz

(xyz){5}

都代表匹配 xyz 5次

---



| 代表或的关系



---



使用 \\ 来引用元字符

用两个反斜线来引用 \\ 本身



# 显示文件



显示文件程序：

less 	cat	head	tail	grep

文本编辑器 vi emacs nano kedit gedit

> 可以使用 vi -R 启动只读模式

二进制查看程序 hexdump od



## less



在显示任何内容之前,less将清空屏幕内容(使用-X)选项禁用

less启动时显示第一屏数据,正好填满显示器或窗口

less下方显示了当前的文件名,阅读百分比等信息

>  可以使用-M来在提示中显示额外信息

> 在使用less时,可以使用h来查看命令列表,是最佳的学习方式



---



基本命令

| 命令       | 作用                     |
| :--------- | ------------------------ |
| h          | 显示帮助                 |
| 空格       | 向下一屏                 |
| q          | 退出                     |
|            |                          |
| g          | 开头                     |
| G          | 结尾                     |
| =          | 显示当前行号和文件名     |
| 回车       | 向下一行                 |
| n+回车     | 前进n行                  |
| b          | 后退一屏                 |
| y          | 后退一行                 |
| ny         | 后退n行                  |
| d          | 前进半屏                 |
| u          | 后退半屏                 |
| <down>     | 前进一行                 |
| <up>       | 后退一行                 |
| <pageUp>   | 前进一屏                 |
| <pageDown> | 后退一屏                 |
| ng         | 跳到第n行                |
| np         | 跳到n%处                 |
| /pattern   | 向后搜索pattern          |
| ?pattern   | 向前搜索pattern          |
| n          | 重复搜索:相同方向        |
| N          | 重复搜索:相反方向        |
| !command   | 执行指定shell命令        |
| v          | 使用当前文件启动vi编辑器 |
| -option    | 改变当前指定option       |
| \_option   | 显示option当前值         |



---



- 搜索

支持正则表达式

使用-I 选项关闭大小写区分



---



**选项**

-s squeeze 挤压	将多个空白行替换为一个空白行

-c clear清除	告诉less从顶端向下显示每一屏数据

-m more	更多提示信息

-M 更多信息

-E 到达文件末尾时自动退出

-F	在整个文件可以一次性显示时自动退出程序

+号指定less从什么地方开始显示数据

-N number	生成行号



---



**环境变量定制**



环境变量PAGER设置默认分页程序

LESS指定启动less时使用的选项



---



**多个文件**

| :n        | 切换到列表中下一个文件 |
| --------- | ---------------------- |
| :p        | 切换到列表中前一个文件 |
| :x        | 切换到列表中第一个文件 |
| :e        | 在列表中插入一个新文件 |
| :d        | 从列表中删除当前文件   |
| :f        | 显示当前文件的名称     |
| =         | 同上                   |
| /*pattern | 向前搜索指定的模式     |
| ?*pattern | 向后搜索指定的模式     |

:e 选项后直接跟文件名可以将新文件插入当前列表的后面



## 原始模式和成熟模式

- I/O概念

设备驱动程序时为操作系统和特定类型的设备提供接口的程序

当使用CLI时,控制终端的程序被称为终端驱动程序



终端驱动程序必须提供一个交互式用户界面,要求对数据进行特殊的预处理和后处理

使用**线路规程**



主要有两种:规范模式和原始模式



- 规范模式(成熟模式)

键入的字符累积在一个缓冲区中,除非按下回车,否则不会向程序发送任何内容

- 原始模式(非规范模式)只要键一按下,字符就直接发送给程序



## 观察不断增的文件的末尾 tail -f

可以逐行观看文件的增长过程

`tail -f [-n +lines] [file...]`

默认显示最后10行

如果文件最后10发生改变,则tail自动显示他们

> 可以结合& 来后台运行tail -f\



## hexdump 和 od

规范格式:

offset hexadecimal ascll



右方的显示ascll字符,不能解释为ascll字符的用 . 代替



---



**hexdump**

-C选项	hexdump自动使用合适的选项组合生成规范输出

-s	允许通过设置初始偏移指定在文件开头略过多少字节

-n	限制输出量

---



**od**

略



# 文件目录



分为三部分:基本概念 目录细节 文件细节

## 基本概念

三个问题:

1. 什么是文件
2. 文件怎么组织
3. 一个独立的系统有没有可能为众多不同类型的数据存储设备提供透明的支持



### 什么是文件

文件是任意源,有一个名称,可以从中读取数据;或者是任意目标,有一个名称,可以向其中写入数据

不止是磁盘文件,键鼠,显示器等物理设备也可以作为文件访问\]



### 文件类型

普通文件	目录文件	伪文件------特殊文件,命名管道,proc文件

---



普通文件：

文本文件和二进制文件

文本文件存储文本数据:纯文本,shell脚本,源程序,配置文件,html文件等



二进制文件:非文本数据

只有在执行或者有其他程序解释时才有意义

可执行程序,对象文件,图像,音乐文件,视频文件,子处理文档,电子表格,数据库

---



目录:目录不存方常规数据,用来组织访问其他文件



---



伪文件:

不用来存储数据,不占用任何空间

提供一种服务,采取和常规文件相同的访问方式进行访问

大多数情况下用于访问内核



- 特殊文件(设备文件)

物理设备的内部表示

- 命名管道

是管道功能的拓展

- proc文件

允许访问内核信息



### 特殊文件

所有的特殊文件存放在/dev 目录中

![image-20240811104336385](C:\Users\32284\AppData\Roaming\Typora\typora-user-images\image-20240811104336385.png)



### 硬件特殊文件

/dev/fd0代表一个软盘驱动器

lp0	打印机

/dev/hda	第一块IDE硬盘

第一块硬盘的分区称为/dev/hda1

SCSI/SATA硬盘的名称味/dev/sda

usb被视为SCSI



## 终端特殊文件tty

终端的特殊文件为tty



伪终端的特殊文件为pty(pseudo terminal)



文件都代表正在使用的终端屏幕

eg.

`cp /etc/passwd/ /dev/tty`

将passwd文件内容显示到终端上



## 伪设备特殊文件

充当输入源或者输出目标,但是不对应于实际设备



**null文件和zero文件**

两个文件都被称为位桶

处理输出时两个的作用相同



区别:

当从/dev/null中读数据时,总返回eof信号

/dev/zero返回和请求一样多的数字0(unix认为是null字符)



---



## 命名管道 mkfifo

`grep bash /etc/passwd | wc -l`



管道没有具体名称,自动创建,称为匿名管道

---



命名管道和匿名管道的区别:

1. 命名管道必须显式创建
2. 命名管道不会消失,必须手动删除

---



称为fifo	first-in first-out

---

**创建**

`mkfifo [-m mode] pipe`



主要用于促进两个进程之间的数据交换,称为**进程间通信**

eg.

```bash
mkfifo fifotest # make a fifo

grep bash /etc/passwd > fifo # send some data

# open another tty
wc -l < fifotest # using fifo from the first tty

# remove fifo
rm fifotest

```





## proc文件

提供一种简单的途径来检查多种类型的系统信息伪文件

存放在/proc目录中

每个进程对应一个子目录,名称就是各个进程的ID

![image-20240811105843579](C:\Users\32284\AppData\Roaming\Typora\typora-user-images\image-20240811105843579.png)



**ps程序通过读取proc文件得到所需数据**



## 树形结构文件系统,文件系统层次结构标准

采用树形结构组织文件

unix系统的标准文件系统组织为:文件系统层次结构标准(FHS)



## 根目录,子目录

unix系统主目录为根目录



/表示根目录

/在文件名中间时充当定界符





## 挂载文件系统:mount,umount

文件存储在许多不同类型的设备上,包括多个磁盘分区



每个存储设备都有自己的本地文件系统,其姆和子目录按照标准Unix方式组织成树.

在访问本地文件系统时,其树必须附加到主树上,通过将小型文件系统的根目录连接到主文件系统中的特定目录上实现

称为**挂载(mount)**该文件系统

小文件系统在主树中附加到的目录称为挂载点

当断开该文件系统时,称为卸载文件系统

---

区别固定介质和可移动介质



固定介质的挂载指定目录是/mnt

可移动介质的挂载点是/media



## 根目录系统

根目录标准内容:

| 目录        | 内容                                   |
| ----------- | -------------------------------------- |
| /           | 根目录                                 |
| /bin        | 基本程序                               |
| /boot       | 启动系统时所需文件                     |
| /dev        | 设备文件                               |
| /etc        | 配置文件                               |
| /home       | 用户的home目录                         |
| /lib        | 共享库,内核模块                        |
| /lost+found | 由fsck回复的受损文件                   |
| /media      | 可移动介质的挂载点                     |
| /mnt        | 不能挂载到其他位置上的固定介质的挂载点 |
| /opt        | 第三方应用                             |
| /proc       | proc文件                               |
| /root       | root用户的home目录                     |
| /sbin       | root用户运行的基本系统管理程序         |
| /srv        | 本地系统提供服务的数据                 |
| /tmp        | 临时文件                               |
| /usr        | 静态数据使用的辅助文件系统             |
| /var        | 可变数据使用的辅助文件系统             |



/bin:最重要的系统程序,即系统管理员在单用户模式下所需的基本工具,都是可执行文件



/boot:系统存放引导过程所需的全部文件的位置,内核必须位于这个目录或者根目录中



/dev:所有的特殊文件,大多数都代表物理设备,少数代表伪设备,makedev程序用于创建新的特殊文件



/etc:配置文件,启动某程序时处理的文本文件



/home:存放个人文件和目录的位置



/lib: 已经存在的数据和代码模块

包含运行/bin和/sbin中的程序所需的基本库和内核模块



/lost+found:若unix没有关机,则仅完成部分写入的文件将受到损坏,下次启动时,一个叫做fsck的程序将自动运行,检查文件系统并修复问题,若发现受损的文件,将其以移动到该目录



/media	/mnt



/srv:存储数据的典型服务包括:cgi,Web,ftp,cvs,rsync等



/tmp用于临时存储



/usr:辅助文件系统的根,包含由辅助文件系统的重要子目录

存放**静态数据**,即没有管理员干涉不会改变的数据



/var:类似/usr,存放可变数据

包括日志文件,打印文件,电子邮件消息等



## /usr目录

| 目录         | 内容                             |
| ------------ | -------------------------------- |
| /usr/bin     | 大多数用户程序                   |
| /usr/include | c程序头文件                      |
| /usr/lib     | 非基本共享库                     |
| /usr/local   | 本地安装程序                     |
| /usr/sbin    | 超级用户运行的非基本系统管理程序 |
| /usr/share   | 共享系统数据                     |
| /usr/src     | 源代码                           |



![image-20240811113121742](C:\Users\32284\AppData\Roaming\Typora\typora-user-images\image-20240811113121742.png)



## 虚拟文件系统

每个存储设备都拥有自己的本地文件系统,访问系统之前,必须连接到主文件系统上,称为挂载



计算机电源打开后,开始引导过程,开机自检后一个称为引导加载程序的程序接管计算机,从**引导设备**读取数据,将操作系统加载到内存中.



在引导设备的数据中有初始的Unix文件系统,称为根文件系统,它自动挂载.存放启动Unix所需的全部程序和数据文件,还包含有系统出现问题时系统管理员所需的工具



一旦挂载了根文件系统,内核启动完毕,就会自动挂载其他设备文件系统,其信息存放在配置文件/etc/fstab中



根文件系统总是存储在引导设备上,当看到登录提示时,所有东西都已挂载完毕



每个设备使用一种适合该设备类型的文件系统,根据设备类型的不同,文件系统在读取和写入数据的细节方面存在巨大差异  

根据文件系统是在本地还是远程(网络),细节也存在着巨大差别  

一些文件系统比如proc文件的procfs,使用伪文件,不驻留于存储设备



常见文件系统:

![image-20240811114105220](C:\Users\32284\AppData\Roaming\Typora\typora-user-images\image-20240811114105220.png)



---



考虑在不同设备之间传输文件(复制等)时,由**虚拟文件系统(VFS)**来处理细节



VFS充当程序和各种文件系统的中间人,每当程序需要I/O操作时,它向虚拟文件系统发送一个请求,VFS自动定位合适的文件系统,通知设备驱动程序执行I/O与之进行通信.



通过这种方式,VFS允许用户和程序以一个单独的一致的树形结构协调工作,即使数据来源于各种独立的异构文件系统



# 目录操作



## 路径名与工作目录

略



## 绝对路径名和相对路径名

若目录序列从根目录开始,则称为绝对路径名;

从工作目录开始,称为相对路径名



## .. . 和 ~

..代表父目录

.代表当前目录

~代表home目录



## cd 和 pwd

cd (change directory)



pwd(print working directory):显示工作目录



**\-**代表上一个目录



## 创建新目录 mkdir

`mkdir [-p] directory...`



创建目录的两个规则:

1. 同一个目录中不能有两个有相同名称的子目录
2. 默认情况下若父目录不存在则不能创建子目录



可以使用-p(make parent)选项忽略第二条限制,将自动创建所有需要的父目录



## 删除目录 rmdir



`rmdir [-p] directory...`



两条规则:

1. 只有当一个目录为空时才可以删除该目录

   > 若向一次性移除一串空目录,需要用-p选项

2. 不能删除任何在工作目录和根目录之间的目录



## 移动或重命名目录 mv



`mv directory target`



使用mv可以将目录从一个位置移动到另一个位置,若在同一个位置,则结果是重命名

> mv移动目录时,同时移动目录中的所有文件和子目录



## 目录栈: pushd popd dirs

使用pushd将目录的名称压入到目录栈中，使用popd命令从栈中弹出一个目录名称，使用dirs命令查看站的内容

```bash
puashd [directory | +n]

popd [+n]

dirs [-c] [-l] [-v]
```

- dirs使用选项时选项必须单独指定,不能连在一起



有用的指令:

| 命令            | 动作                                |
| --------------- | ----------------------------------- |
| dirs            | 显示名称                            |
| dirs -l         | 显示名称,home目录显示为完整名称     |
| dirs -v         | 显示名称,每行一个,且有数字标识      |
| pushd directory | 改变工作目录,将directory压入栈中    |
| pushd +n        | 改变工作目录,将目录n移到栈顶        |
| popd            | 改变工作目录:弹出栈顶               |
| popd +n         | 从栈中移除目录n                     |
| dirs -c         | 除当前工作目录外,移除栈中的全部目录 |

- 这三个命令都是shell内置命令

> 建议的别名:alias d='dirs -v' 	alias p=pushd



## ls

ls的默认行为是按照字母表顺序显示目录中各个文件的名称



可以使用多个目录名称



默认显示工作目录中的文件



当ls的输出重定向到其他文件或者管道线时,ls以每个文件独占一行的形式输出,可以使用-C选项强制ls以列的形式将输出写入到文件或者管道线中



-1 选项强制ls以每个文件名占一行的形式将输出写入到文件或者管道线中



-r 选项以相反的顺序显示文件名



-R 选项显示指定目录中的所有直接或间接的子目录和文件的信息,即整个目录树的信息



---



-F 选项检查文件类型,在文件后加上标志

| 标志 | 含义                  |
| ---- | --------------------- |
| 空   | 普通文件,非可执行文件 |
| *    | 普通文件:可执行文件   |
| /    | 目录                  |
| @    | 符号链接              |
| \|   | 命名管道/FIFO         |



---



--color选项指示ls使用颜色标识不同的文件

--color=always/yes/force	使用颜色

--color=never/no/none	不使用颜色

--color=auto/tty/if-tty	只有在输出到终端上时才使用颜色



---

点文件(隐藏文件):ls -a



没有仅显示点文件的命令,但可以使用通配符来显示

`ls -a .[a-zA-z]*`



下面的命令显示点文件,但是忽略.,..和隐藏目录的内容

`ls -d .??*`

> -d 选项只显示目录本身,不显示目录的内容

有用的点文件:

![image-20240811150812831](C:\Users\32284\AppData\Roaming\Typora\typora-user-images\image-20240811150812831.png)



---



**长目录列表**

ls -l显示文件的详细信息

```bash
total 7416
drwxr-xr-x  5 mirai mirai    4096 Aug 11 15:09 ./
drwxr-x--- 11 mirai mirai    4096 Aug 11 15:06 ../
lrwxrwxrwx  1 mirai mirai       5 Aug  9 21:02 backups -> wxtra/
-rw-r--r--  1 mirai mirai       0 Aug 10 10:40 bar
drwxr-xr-x 22 mirai mirai    4096 Aug  9 17:57 cpp-code/
-rwxr-xr-x  2 mirai mirai 2476795 Aug  8 19:41 g2.txt*
-rwxr-xr-x  2 mirai mirai 2476795 Aug  8 19:41 gone-with-wind.txt*
-rwxr-xr-x  1 mirai mirai   21030 Aug  8 16:59 linux.md*
drwxr-xr-x  3 mirai mirai    4096 Aug  9 17:01 py-code/
-rw-r--r--  1 mirai mirai   17734 Aug  8 16:58 vi-exercise
drwxr-xr-x  2 mirai mirai    4096 Aug  9 21:04 wxtra/
-rwxr-xr-x  1 mirai mirai 2570501 Aug  8 17:01 红楼梦.txt*
```

最右边是文件名



最左边一列是文件类型

| 指示符 | 含义               |
| ------ | ------------------ |
| -      | 普通文件           |
| d      | 目录               |
| l      | 符号链接           |
| b      | 特殊文件(块设备)   |
| c      | 特殊文件(字符设备) |
| p      | 命名管道/FIFO      |



文件名左边是时间和日期,为修改时间,可以使用-lu选项显示访问时间,即上一次读取文件的时间

使用-t选项按照时间顺序显示文件

与-r反转选项结合



列表最顶端显示被列举文件所使用的文件系统块的总数量



日期左边是一个以字节为单位的文件大小,显示了文件包含的实际数据量,而不是文件占用的存储空间

使用-h 选项加上单位



文件大小的左边是两个名称:文件属主的用户标识和组,以及该用户标识所属的组



用户标识的左边是显示该文件有多少个链接的数字



再左边的9个字符的字符串是文件的权限



---



有用的别名

```bash
alias ls='ls -F --color=auto'

alias ll='ls -l'
alias la='ls -a'
alias lla='ls -la'
alias ldot='ls -d .??*'

```





## 检查文件类型,file

file可以描述几千种类型的文件

只需指定一个或多个文件或目录的名称即可



## 磁盘空间使用情况: ls -hs du df quota

ls -s告诉ls在每个文件名前面以KB为单位列出文件的大小

如果指定的是目录名称,则ls显示整个目录的总大小



可以使用-h选项来显示单位



---



**du(disk usage)**

显示文件的大小

`du [-achs] [name...]`

当指定一个或多个文件的名称时,du将显示这些文件所使用的存储空间总量



-h选项加上单位



-k选项强制使用kb作为单位



默认情况下du将显示工作目录以及旗下子目录的所有文件等的信息



-s 显示总和,减少输出量



-c 选项在输出末尾显示总量,在于-s 和 -h选项结合时有用(把多个文件的大小加起来)

-csh



-a 选项,显示所处理的每个目录和文件的大小



---



**df(disk free-space)**

显示每个文件系统已经使用了多少磁盘空间,以及还有多少磁盘可用空间



-h 选项显示单位



---



**quota**

quota产看系统管理员分配给每个用户的可使用的配额,规定每个用户表示只允许使用多大的磁盘空间



## 块和分配单元: dumpe2fs

- 文件所使用磁盘空间的数量不同于文件中数据的数量

> 在文件系统中,空间以固定大小的**组块**进行分配,将固定大小的组块称为**块**
>
> 根据文件系统的不同,块的大小有512字节,1kb,2kb或者4kb
>
> 为文件所分配的最小磁盘空间数量就是一个块
>
> 假如一个文件系统的块大小是1kb,则仅包含1字节的文件也要占据一个完整的块,若文件的大小大于一个块,则需要第二个块





> 当文件写入到磁盘或其它存储介质上时,处于效率方面的考虑,磁盘的存储空间也以固定大小的组块分配,称之为**分配单元**或者**簇**
>
> 分配单元的大小取决于文件系统和存储设备
>
> eg.一个快的大小为1k,但是磁盘分配单元为8k,则一个只有一个字节的文件实际上要占用8k的磁盘空间



下面是查看分配单元和块大小的方法:

- 分配单元

首先创建一个小文件,只包含两个字符

使用ls -l命令2显示文件包含的数据的数量,应该为2字节

使用du查看文件占用的磁盘空间,就是磁盘的分配单元的大小



- 块

> 文件系统中所有的数据都组织成块,其中有一个块称为超块,是一个特殊的数据区,存放于文件系统本身有关的关键信息

查找表示文件系统的特殊文件的名称(使用df程序)

登录到超级用户

运行dumpe2fs /dev/sdc

我们需要的数据位于Block size的行上,使用grep即可



## 使用通配符进行通配



每当键入以文件名作为参数的命令时,,可以通过使用特定的元字符---**通配符**指定多个文件名



与正则表达式极其相似



只有一个用途:当键入一条命令时匹配一组文件名

| 符号                  |                                   |
| --------------------- | --------------------------------- |
| *                     | 匹配任何0个或者多个字符构成的序列 |
| ?                     | 匹配任何单个的字符                |
| [list]                | 匹配在list中的任何字符            |
| [^list]               | 匹配不在list中的任何字符          |
| {string1\|string2...} | 匹配其中一个指定的字符串          |



根据所使用的shell不同,使用通配符指定文件的正式称呼也有所不同,在bash中称为路径名拓展  

当shell执行是集体还是,称之为通配(globbing)



方括号中可以用-指定范围[0-9] \[a-z] \[A-Z]等



可以使用和正则表达式相同的预定义类

---

**花括号扩展**



告诉shell依次使用每种模式形成一个单独的文件名

- 逗号两边不要加空格

eg.

将olddata1,olddata2,olddata3,newdata1,newdata2,newdata3结合起来,输出到master中

可以使用

`cat olddata1 olddata2 olddata3 newdata1 newdata2 newdata3 > master`

也可以

`cat {old,new}data{1,2,3} > master`

`cat {old,new}data[1-3] > master`



## 显示目录树 tree

`tree [-adfFilrst] [-L level] [directory...]`



其中level是树的深度



-a 显示所有文件包括点文件

-s 显示文件名的同时显示文件大小

-F 显示表示文件类型的标志

-r 按相反顺序对输出排序

-t 按修改时间对输出排序

-d 只显示目录

-f 显示完整目录名

-i 省略缩进

-L 后跟数字限制树的深度

-l 跟随所有的符号链接



## 目录管理器

使用vim加目录名,可以对目录中的文件执行基本操作







# 文件操作



## 创建文件 touch

实际上unix在需要时会自动创建文件

1. vi打开文件

2. 重定向向文件输出
3. cp复制命令



若要创建空文件,可以使用touch

touch不是创建新文件的命令,主要用于在不改变文件的情况下改变文件的修改时间和访问时间

其副作用使其可以创建空文件

---



`touch [-acm] [-t time] file`



其中time是时间,默认情况下,touch将修改时间和访问时间修改为当前时间



-m 仅改变修改时间

-a 仅改变访问时间

-t 使用具体的时间和日期取代当前时间

-c 不创建文件



## 命名文件

两条基本规则

1. 文件名长达255个字符
2. 文件名可以包含除/和null外的任何字符



最好只使用字母,数字,下划线,点号,连字符



- 命名目录和文件时最好只使用小写字母



> 不要为shell脚本使用test的文件名,否则会和shell内置test命令冲突



## 复制文件:cp



`cp [-ip] file1 file2`

将file1复制到file2



若目标文件不存在,则cp创建该文件,否则cp替换已存在文件



若希望在文件末尾追加数据,则不能使用cp程序



-i 选项在替换已有文件之前进行询问

-p 选项使目标文件和源文件拥有相同的修改时间,访问时间,以及权限



---



将文件复制到不同的目录中



`cp [-ip] file... directory`



---



将目录复制到另一个目录中:cp -r



cp -r dir1 dir2



dir1的副本包括其中所有的文件和子目录都复制到dir2中



> 为了复制目录中的所有文件,可以使用通配符
>
> `cp documents/* backups`
>
> 为了复制目录本身以及其中包含的全部文件和子目录,可以使用-r选项
>
> `cp -r documents backups`



## 移动文件:mv

 

`mv [-if] file... directory`



将一个或多个文件移动到==已有==目录中

> 若目录不存在,则mv认为希望重命名文件



若文件在目标目录中存在,那么源文件将替换目标文件,可以使用-i选项来指示是否替换

-f选项强制在不询问的情况下替换文件



---



重命名文件或目录



## 删除文件 rm

`rm [-fir] file...`



- 该命令为移除而不是删除



-i 选项进行交互式删除

-f 强制删除,忽略文件权限,会覆盖-i选项



----



rm -r递归删除目录树



## 文件权限



权限分为三种:读权限,写权限,执行权限



文件权限依赖文件类型



三种类型的权限是有相互区别的,但是可以结合使用,比如为了修改一个文件,需要同时具有该文件的读权限和写权限



对普通文件来说三种权限十分直接

对目录而言,读权限可以读取目录,写权限可以创建,移动.复制.删除目录条目,执行权限可以搜索目录



## setuid

当有一个当前用户权限不足而不可以读的文件时,可以有三种选择

1. 改变文件的权限
2. 使用一个拥有该文件的读权限的用户标识登录
3. 使用超级用户登录



有时候,普通的用户标识可能需要以特殊的权限运行程序,为此设计了一个特殊的权限,以允许以他的用户标识访问文件,就好像他们是文件的属主一样.

该权限被称为setuid或者suid,代表'set userid'设置用户标识



大多数情况下用来允许普通用户标识运行从root拥有的程序中挑选的程序



若文件长列表中的x被s替代,则代表文件有setuid权限



## unix维护文件权限的方式:id groups

创建文件的用户标识就是文件的属主,属主和超级用户是可以改变文件权限的唯二用户标识



第一组用户权限描述属主如何访问文件



每个用户都属于一个组,第二组权限应用于和属主位于同一组的所有其他用户标识,第三组权限应用于系统上的其他用户标识



使用id命令查看用户标识和组标识

使用groups命令显示自己或指定uid的所属组



现代unix系统允许用户同时属于多个组,其中口令文件中给出来的组称为主组,其他的组称为辅组



## ls -l显示的文件权限信息

r=读权限

w=写权限

x=执行权限

-=没有权限

将9个字符从左到右分为三组,分别是属主,组,系统上所有其他用户



## 文件模式

unix使用一个紧凑的三位数字的代码来标识一个完整的文件权限集,该代码称为文件模式,简称为模式



代表各种权限的数字值:

4=读权限

2=写权限

1=执行权限

0=没有权限

对于每一组权限来说,只需将适当的数字加在一起即可

下面是每种可能的组合以及对应的数字值

| 读   | 写   | 执行 | 分量  | 和   |
| ---- | ---- | ---- | ----- | ---- |
| -    | -    | -    | 0+0+0 | 0    |
| -    | -    | 有   | 0+0+1 | 1    |
| -    | 有   | -    | 0+2+0 | 2    |
| -    | 有   | 有   | 0+2+1 | 3    |
| 有   | -    | -    | 4+0+0 | 4    |
| 有   | -    | 有   | 4+0+1 | 5    |
| 有   | 有   | -    | 4+2+0 | 6    |
| 有   | 有   | 有   | 4+2+1 | 7    |



## 改变文件权限

使用chomod(change file mode)命令



`chomod mode file...`



mode是新文件模式



## unix为新文件指定权限的方式:umask

当unix创建新文件时,将根据文件的类型为文件指定下述几种模式:

666:不可知性的普通文件

777:可执行的普通文件

777:目录



在初始模式上,unix减去**用户掩码**的值



使用umask指令设置用户掩码

`umask mode`

最好放在登陆文件中



若想让文件是专用的,就设置为077,这样自己有文件的一切权限而其他人没有任何权限



使用没有参数umask显示当前的掩码之

- umask是一条内置命令,依赖于所使用的shell



## 清空文件内容:shred



删除文件后,文件实际使用的磁盘空间还没有被清除,文件系统只是将这部分磁盘空间表示为可以重用.



shred程序的目的是多次覆盖磁盘上已有数据,从而彻底删除文件

`shred -fvuz [file...]`

-v 选项在处理过程中自动显示处理消息



默认情况下shred在结束任务时将文件包含完全随机的数据,

使用-z选项将文件最终全部使用0填充

使用-f忽略文件权限

使用-u在处理之后删除文件



## 链接的概念 stat,ls -i

当unix创建文件时,完成两件事

1. 在存储设备上保留一块空间用来存储数据
2. 创建**索引节点/i节点**的结构存放文件的基本信息

i节点包含使用文件所需的全部文件系统信息,典型的内容如下:

```txt

- 以字节为单位的文件长度
- 包含该文件的设备名称
- 属主的用户标识
- 组id
- 文件权限
- 上一次修改时间
- 上一次访问时间
- i节点上一次修改时间
- 指向该文件的链接数
- 文件的类型
- 分配给该文件的块数

```

使用stat filename查看文件的i节点信息



---



文件系统将所有的i节点放在一个大表中称为**i节点表**

每个i节点由索引号或者i节点号标识

使用ls -i显示节点号



- 目录中不包含文件,只包含文件的名称和文件的节点号



在foo目录中创建文件bar时发生的事情:

1. 首先unix在硬盘上保留存放该文件的存储空间
2. 查看i节点表,查找一个空闲的i节点,假如是#114514,将信息填充到属于该文件的i节点

3. 在foo目录中放一个条目,包括名称bar以及一个为114514的i节点号
4. 使用该文件时,程序使用相应的i节点查找i节点,然后使用i节点中的信息访问该文件



- 文件名和i节点之间的连接称为**链接**

- 一个i节点可以由不止一个文件名引用



## 多重链接

一个文件可以有多个不同名称

因为文件的唯一标识是其i节点号而不是文件名称,所以多个文件名可以引用同一个i节点号



- 链接是文件操作的基础
- unix平等地对待每一个链接



- 文件不由名称或者位置控制,只受所有权和权限控制



## 创建新连接:ln

每当创建文件时，文件系统都会在文件名和文件hi见创建一个链接

可以使用ln命令手动为文件创建链接

1. 为单个文件创建新链接

`ln file newname`
file是一个已有的普通文件的名称,newname是希望赋予链接的名称

eg.
`ln spacewar funky`
这两个文件名都指向同一个文件

2. 为一个或多个普通文件创建新链接,并将新链接放在指定目录中

`ln file... firectory`



## 基本文件命令的工作方式



1. 创建文件,创建目录

unix留出相应的存储空间并创建i节点,然后unix在适当的目录中通过使用指定的文件名或目录名以及新i节点的i节点号置入一个新条目

2. 复制文件

unix用源文件(要复制的文件)的内容替换目标文件的内容,但是i节点号不改变

当复制到一个不存在的文件时,unix首先用新文件自己的i节点号创建一个全新的文件,然后将就文件的内容复制到新文件中,复制后得到两个相同的文件但是i节点号不同

3. 重命名或移动文件

unix仅改变文件名或改变目录条目,但是i节点号不变

4. 创建链接

unix使用指定的文件名创建一个新的目录条目,指向原始文件的i节点号,一个文件拥有两个文件名,但是指向相同的i节点号

5. 移除链接

unix移除目录条目,消除文件名和i节点号之间的连接,若文件已经没有链接,unix会删除文件

*链接的移除和文件的删除不是一回事*



## 符号链接 ln -s



在创建不同文件系统中的目录或文件的链接时,需要创建符号链接,需要使用带-s选项的ln命令

符号链接包含的不是文件的i节点号,而是源文件的路径名,当访问符号链接时,unix借助路径名查找文件



常规的链接称为硬链接,符号链接称为软链接



**若某一文件存在符号链接,则删除文件后符号链接不会被删除,使用ls时会报错**

---

使用符号链接

当目录名称是另一个目录的符号链接时,有两个选择:

1. 将符号链接视为一个实体.
2. 定位到真实位置

cd有两个选项:

1. -L	将符号链接视为真实的目录
2. -P        用真实目录替换符号链接



## whereis 查找与unix命令相关的文件

whereis用来查看与特定的unix命令相关的文件:二进制文件,源文件,文档文件

whereis不搜索整个文件系统,而只查看那些此类文件中极可能存在的目录



-b	只显示可执行文件

-m	只显示联机手册中的文件

-s	只显示源文件



## 搜索数据库查看文件 locate

locate搜索一个特殊的数据库(包含所有可公共访问的文件的路径名),查找所有包含特定模式的路径名.该数据库自动维护,并定期更新.

`locate [-bcirS] pattern`

-r	可以使用正则表达式

-c	显示匹配的文件总数,而不显示实际的文件名

-i	忽略大小写

-b	只显示路径名的最后一部分

-S	显示系统locate数据库信息

> 缺点:数据库定期自动更新,但是新创建的文件并不会立刻出现在数据库中



## 搜索目录树查找文件:find

查找一个或多个目录树,根据指定的测试条件,查找满足特定标准的文件,一旦搜索完成,find对查找到的文件执行某种动作

`find path... test... action`

---

**test**

| 文件名             |                                   |
| ------------------ | --------------------------------- |
| -name pattern      | 包含pattern的文件名               |
| -iname patern      | 包含pattern的文件名(不区分大小写) |
|                    |                                   |
| 文件特征           |                                   |
| -type [df]         | 文件类型为目录或普通文件          |
| -perm mode         | 设置为mode的文件权限              |
| -user userid       | 属主为userid                      |
| -group groupid     | 组为groupid                       |
| -size [-+]n[cbkMG] | 大小为n[b,块,kb,mb,gb]            |
| -empty             | 空文件(大小=0)                    |
|                    |                                   |
| 访问时间,修改时间  |                                   |
| -amin [-+]n        | n分钟之前访问                     |
| -anewer file       | file文件之后访问                  |
| -atime [-+]n       | n天之前访问                       |
| -cmin [-+]n        | n分钟之前状态改变                 |
| -cnewer file       | file文件之后状态改变              |
| -ctime [-+]n       | n天之前状态改变                   |
| -mmin [-+]n        | n分钟之前修改                     |
| -mtime [-+]n       | n天之前修改                       |
| -newer file        | file文件之后修改                  |

**通配符使用时需要引用**

-+代表大小

---

使用!对测试求反

eg.

`find ~ -type f \! -name '*.jpg' -print`

显示拓展名不是.jpg的文件

---

**动作**

| 动作                |                                |
| ------------------- | ------------------------------ |
| -print              | 将路径名写入标准输出           |
| -fprint file        | 输出写入file                   |
| -ls                 | 显示长目录列表                 |
| -fls file           | 写入file                       |
| -delete             | 删除文件                       |
| -exec command {} \; | 执行command,{}指示匹配的文件名 |
| -ok command {} \;   | 同上,在运行command之前进行确认 |

-ls	类似使用-dils选项的ls命令的信息



## 处理查找到的文件:xargs

对于find来说,假如搜索到57个文件,则-exec生成57条单独的命令

此时可以使用xargs程序来处理

`xargs [-prt] [-istring] [command [argument..]]`



command是希望运行的命令,string是占位符,argument是从标准输入读取的参数

(这里的参数可以理解为从管道传过来的内容,也就是标准输入读取)

当处理find的输出时,echo命令是否有用,echo对参数求值并写入标准输出中,若传给echo一串路径名,那么echo将输出一个包含所有名称的长行,即可用管道传给另一个程序来进一步处理



-i	选项允许使用{}作为占位符,在命令运行之前被参数取代

-p	在执行命令前请求许可

-t	在执行过程中显示每条命令

**-i选项不能和其他选项一起使用**

-r	选项告诉xargs若没有输入参数,则不运行命令



# 进程和作业控制

## 内核管理进程的方式

进程是一个加载到内存中准备运行的程序，再加上程序所需的数据以及跟踪管理程序状态所需的各种信息

进程创建时，内核赋予其唯一的标识号，称为**进程ID(PID)**

内核中维护了一个进程表,按照PID索引,每个进程在进程表中有一个条目.进程表中的每个条目还包含有描述及管理进程所需的信息

为了管理大量的进程,内核提供了一个复杂的调度服务,称其为**调度器**

调度器维护一个所有正在等待执行1的进程的列表,调度器每次选择一个进程,给予其在一个短暂的时间间隔(**时间片**)内运行的机会

通常将处理时间称为CPU时间

## 进程分叉到死亡

除了初始进程外,每个进程都是由另一个进程创建的

内核为进程提供基本的服务,包括

- 内存管理(虚拟内存管理,分页)
- 进程管理(进程创建,终止,调度)
- 进程间通信(本地,网络)
- 输入输出
- 文件管理
- 安全和访问控制
- 网络访问(TCP/IP)

当进程需要内核执行服务时,使用**系统调用**发送请求

> echo $$显示当前shellpid

当shell运行外部命令时,shell必须创建一个新进程,下面是其工作方式:

​	使用fork创建一个新的进程,原始进程成为父进程,新进程成为子进程;子进程调用exec函数执行外部程序;父进程调用wait函数等待子进程死亡;最终外部程序死亡,子进程使用exit系统调用停用自身.

当程序永久停止后,不管由于什么原因,都成为进程**死亡**或者**终止**

当进程死亡时,所使用的资源--内存,文件等--都被释放,从而可以被其他进程使用,此时被杀死的进程为僵进程.但是仍在进程表中保留着自己的条目,包含着最近死亡的子进程的数据,父进程可能对这些数据感兴趣.

## 孤儿进程和废弃进程

如果子进程的父进程停止,则子进程成为孤儿进程,在死亡后不会被父进程回收,而是被#1进程回收.

## 区分父进程和子进程

父进程的fork系统调用返回子进程的pid,子进程返回0

## 第一个进程init

在启动操作的引导过程结束之前,内核创建一个特殊的进程,pid为#0,称为**空闲进程**

空闲进程在初始内核所需的数据结构等之后,进行分叉,创建#1号进程,然后空闲进程进入死循环.

每当没有程序等待执行时,调度器就执行空闲进程,当#0进程称为空闲进程时,使用ps命令显示#0进程的状态,内核将否定该进程的存在

进程#1执行设置内核及结束引导过程所需的剩余步骤,称为**初始化进程(init)**

> init进程运行包含在文件/etc/inittab中的shell脚本,这一过程中init多次分叉,创建运行系统所需的基本进程,并允许用户登录,在这一国中,init成为系统中所有其它进程的祖先

#1进程永远不会停止,直到系统关闭

## 前台进程和后台进程

在命令后输入&即可将命令作为后台进程,后台进程在后台运行,输入被隔断,但是输出仍存在,包括标准输出和标准错误输出

使用fg+进程号将后台进程作为前台进程

后台进程不相应intr(\^C)和quit(\^\\)信号,(quit信号生成一个供调试使用的磁芯转储)

## sleep

使shell暂停一段时间

`sleep interval [s|m|h|d]`

## 作业控制

在命令末尾输入&后,进程以**异步进程**运行,有两个特征:

1. 默认情况下,标准输入与/dev/null链接
2. 进程不相应intr和quit信号

作业控制使多个进程同时运行成为可能,一个进程在前台运行,其他的进程在后台运行.

作业控制的本质使将每条输入的命令视为一个作业,由唯一的一个**作业号(ID)**标识,为了控制和管理作业,可以将作业的ID和一系列命令等一起使用

- 作业控制命令

| jobs    | 显示作业列表                      |
| ------- | --------------------------------- |
| ps      | 显示进程列表                      |
| fg      | 将作业移至前台                    |
| bg      | 将作业移至后台                    |
| suspend | 挂起当前shell                     |
| ^Z      | 挂起前台作业                      |
| kill    | 向作业发送信号;默认情况下终止作业 |

- 变量

| echo $$ | 显示当前shell的PID            |
| ------- | ----------------------------- |
| echo $! | 显示上一条移至后台的命令的PID |

- 终端设置

| stty tostop  | 挂起试图向终端写数据的后台作业 |
| ------------ | ------------------------------ |
| stty -tostop | 关闭tostop                     |

- shell选项(Bash,Korn shell)

| set -o monitor   | 允许作业控制             |
| ---------------- | ------------------------ |
| set +o nomonitor | 关闭monito               |
| set -o notify    | 当后台作业结束时立刻通知 |
| set + nonotidy   | 关闭notify               |

> 当使用管道线时,每个命令视为一个单独的进程,但是整个管道线视为单独的作业

## 挂起作业

在任何时候,作业都处于三种状态的其中一种:前台运行,后台运行,暂停并等待信号恢复执行.

当需要暂停前台作业时,可以用^Z,发送susp信号,使进程暂停,称将进程**挂起(停止)**

当挂起作业时,今晨会无限期停止,若注销系统,会产生问题,所有挂起的作业自动终止.

## 挂起shell:suspend

使用suspend命令挂起当前shell.

使用fg将挂起的shell再次移到前台

可以用于切换不同用户或shell时使用

## 显示作业列表:jobs

jobs显示作业信息:包括作业号,状态,命令

使用-l选项显示进程号

在列表中有一个作业标记有一个+号,代表当前作业,-号代表前一个作业

在使用fg和bg时,默认作用为当前作业,即最近挂起的那个作业

## 将作业移至前台:fg

```bash
fg
fg %[job]
%job
```

最简单的fg,告诉shell重新启动当前作业,即在使用jiobs时列出的带有+标记的作业

为了移动不是当前作业的作业,需要标识这个作业,方法如下

| 作业号 | 含义                           |
| ------ | ------------------------------ |
| %%     | 当前作业                       |
| %-     | 前一个作业                     |
| %+     | 当前作业                       |
| %n     | 作业#n                         |
| %name  | 含有指定命令名的作业           |
| %?name | 命令中的任意位置含有name的作业 |

> 只要指定命令的足够部分到足够从所有作业中区分出来某一命令即可

> fg % - 可以在两个作业间快速切换

单独一个%字符告诉shell将当前作业移至前台

## 将作业移至后台:bg

和fg类似

## 进程状态显示程序: ps

**基本技能**

`ps [-aefFly] [-p pid] [-u userid]`

| 显示哪些进程 |                                |
| ------------ | ------------------------------ |
| ps           | 与当前用户标识和终端相关的进程 |
| ps -a        | 与任何用户标识和终端相关的进程 |
| ps -e        | 所有进程(包括守护进程)         |
| ps -p pid    | 与指定pid相关的进程            |
| ps -u userid | 与指定用户userid相关的进程     |

| 显示哪些数据列 |                                                      |
| -------------- | ---------------------------------------------------- |
| ps             | PID TTY TIME CMD                                     |
| ps -f          | UID PID PPID C TTY TIME CMD                          |
| ps -F          | UID PID PPID C SZ RSS STIME TTY CMD                  |
| ps -l          | F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD |
| ps -ly         | S UID PID PPID C PRI NI RSS SZ WCHAN TTY TIME CMD    |

| 有用的特殊组合 |                           |
| -------------- | ------------------------- |
| ps             | 显示自己的进程            |
| ps -ef         | 显示所有用户进程,完整输出 |
| ps -a          | 显示所有非守护进程的进程  |
| ps -t -        | 仅显示所有守护进程        |

| unix标题 | 含义                     |
| -------- | ------------------------ |
| ADDR     | 进程表中的虚拟地址       |
| C        | 处理器利用率(废弃率)     |
| CMD      | 正被执行的命令的命令名称 |
| F        | 与进程相关的标志         |
| NI       | nice值,用于设置优先级    |
| PID      | 进程id                   |
| PPID     | 父进程的pid              |
| PRI      | 优先级(大数字=低优先级)  |
| RSS      | 内存驻留空间大小         |
| S        | 状态代码(D,R,S,T,Z)      |
| STIME    | 累积系统时间             |
| SZ       | 物理页大小(内存管理)     |
| TIME     | 累积cpu时间              |
| TTY      | 控制终端的完整名称       |
| UID      | 用户标识                 |
| WCHAN    | 等待通道                 |

| 状态代码 |                                             |
| -------- | ------------------------------------------- |
| D        | 不可终端睡眠,等待事件结束(通常为I/O,D=disk) |
| I        | 空闲:超过20s的睡眠(仅适用于FreeBSD)         |
| R        | 正在运行或可运行(可运行=在运行队列中等待)   |
| S        | 可中断睡眠,等待事件结束                     |
| T        | 挂起,有作业控制信号挂起或者因为追踪而被挂起 |
| Z        | 僵进程:终止后父进程没有等待                 |

ps的使用基本是基于目的查表然后选择选项

## 监视系统进程:top

ps的限制是只显示静态的快照,即进程的瞬间状态

top用于每个几秒钟显示系统的统计更新,并实时显示最重要的进程信息

top显示使用最多cpu时间的进程

基本语法如下,但是随系统不同而不同,记得查看手册

`top [-d delay] [-n count] [-p pid[,pid]...]`

delay是刷新间隔,count是刷新的总次数,pid是进程id

## 显示进程树:pstree

pstree显示父进程和子孙之间的连接

`pstree [-aAcGnpu] [pid | userid]`

显示的进程树在每一层都按照字母顺序排列

数字+*代表有完全相同的子树,若不希望压缩,使用-c(do not compact)选项

-A强制使用ascll字符绘制

-G强制使用行绘制字符

-p	显示每个进程的pid

-n	按pid对进程排序

可以加上进程号显示从指定进程开始的进程树

可以加上用户标识显示指定用户的进程树

## 显示使用文件的进程 fuser

列举所有正在使用一个给定文件的进程

fuser file

显示所有正在使用file文件的进程的进程id

> fuser程序通常存放在管理目录,可能在非超级用户模式下其位置不在自己的搜索路径中,使用whereis命令查询位置,并加上绝对路径来运行该程序

## kill发送信号

`kill [-9] pid... | jobid...`

-9	''确定杀死'信号,该选项不允许进程释放正在使用的资源,比如可能不关闭文件,释放内存等

- 常用信号

| 编号 | 名称    | 缩写 | 描述                                  |
| ---- | ------- | ---- | ------------------------------------- |
| 1    | SIGHUP  | HUP  | 中止:注销或终端失去连接时发送给进车给 |
| 2    | SIGINT  | INT  | 中断:按下^C时发送                     |
| 9    | SIGKILL | KILL | 杀死:立即终止,进程不能捕获            |
| 15   | SIGTERM | TERM | 终止:请求终止,进程不能捕获            |
| 18   | SIGCONT | CONT | 继续:恢复挂起的进程,由fg或bg发送      |
| 19   | SIGSTOP | STOP | 停止(挂起):按下^Z时发送               |

kill -l查看支持的信号类型

不指定信号,默认发送TERM信号

eg.

`kill -STOP 3662`

## 设置进程的优先级:nice

在调度器管理分配资源是,认为每个进程都关联有一系列的不同的值

其中一个比较重要的值是**优先级**,用来指示一个进程相对于其他进程有多大的优先权.

`nice [-n adjustment] command`

adjustment是一个数值,command是希望运行的命令

默认情况下nice使程序以较低的优先级运行

==注意==

1. nice只能应用于自己独立的程序,不能用于shell内部命令
2. 只能对后台程序运行nice

-n	后跟nice值,即优先级值,从0-19

nice值越高,优先级越低

当以普通方式运行命令(不使用nice)时,赋予程序的nice值是0

当不带-n使用nice时,默认nice值是10

超级用户可以使用负的nice值来提高优先级

## 改变现有进程优先级:renice

`renice niceness -p processid`

niceness是nice值,processid是进程id

## 守护进程

大多数进程不是由用户运行的程序,这些进程是**守护进程**

即在后台运行的程序,完全不与任何终端连接,目的是提供服务.一般情况下,守护进程在后台等待某些事件的发生:事件,请求,中断,给定的时间间隔等

ps输出列表中TTY列的?字符代表守护进程

下面是一些守护进程

![image-20240812171937581](C:\Users\32284\AppData\Roaming\Typora\typora-user-images\image-20240812171937581.png)

 