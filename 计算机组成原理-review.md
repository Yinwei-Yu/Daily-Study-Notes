
# 第一章

## 七个伟大思想

1. 抽象简化设计
2. 加速经常性事件
3. 并行
4. 流水线
5. 预测
6. 存储层次
7. 通过冗余提高可靠性

## 性能

### 度量性能

1. 挂钟时间 响应时间 运行时间
包括:磁盘访问,内存访问,IO操作和os开销
2. cpu时间
只在cpu上花费的时间,包括用户cpu时间和系统cpu时间(操作系统帮用户执行的任务)

### 计算

1. cpu时间=cpu周期数 x 周期时间=周期数/cpu频率
2. cpu周期数=程序指令数 x 指令平均时钟周期数(CPI)
3. cpu时间=指令数 x CPI / cpu频率

注:
- cpu主频提高和周期数增加不成正比
- ISA称为指令集架构,相同指令集架构的CPI也不一定相同
- 在比较性能强弱时使用比值,强的做分子

### 计算-2

不同种类的指令的CPI不同,所以采用分层计算

eg.
![[Pasted image 20241015185809.png]]

## 影响程序性能的因素

| 硬件或软件指标  | 影响什么         |
| -------- | ------------ |
| 算法       | IC(指令数),cpi  |
| 编程语言     | 同上           |
| 编译器      | 同上           |
| 指令系统体系结构 | 指令数,时钟频率,cpi |

## 功耗墙

由于功耗限制
当功耗上升时,无法再降低硬件的电压和散出足够的热量
从而摩尔定律受到影响
现在处于后pc时代

# 第二章

除浮点数外的指令集:
[[计算机组成原理-en.pdf#page=278&selection=0,3,14,19|基本指令集]]

各种指令格式:
[[riscv基本指令集.pdf#page=1&selection=1,1,2,43|指令格式]]


## 指令类型

1. 运算指令
	1. 算数运算
	2. 逻辑运算
2. 数据传输
	1. load
	2. store
	3. 外设IO读取
3. 控制指令
	1. 条件分支
	2. 无条件分支

## 指令格式

### 概述

1. 指令固定为32位,四个字节
2. 操作码固定7位
3. 操作数长度25位
	1. 寄存器
	2. 内存
	3. 立即数

### R型指令 op rd rs1 rs2 opcode=0110011

![[Pasted image 20240920151101.png]]
包括:	
1. add,sub
2. sll,srl,sra
3. or,and,xor
4. slt,sltu(小于置位指令)

funct3和funct7区分具体指令
### I型指令 op rd rs imm 

![[Pasted image 20240920152324.png]]

包括:
1. addi,subi
2. slli,srli,srai
3. ori,andi,xori
4. slti,sltui
5. lb,lh,lw,lbu,lhu
6. ==jalr== jalr,x0,0(x1) 跳转到x1的地址,将pc+4存到x0,即舍弃pc+4

立即数范围: $-2^{11}$ ~ $2^{11}-1$


### S型指令 op rs1 imm(rs2)

![[Pasted image 20240920153828.png]]

包括:
	sb
	sh
	sw
	
为什么要把立即数拆开?
和R型指令保持一致
### SB型指令 op rs1 rs2 Label

![[Pasted image 20241015192827.png]]
第11位和12位的设计和S型指令保持一致
12位做最高位保持符号
最低位不存储,补0,因为指令的地址都是4的倍数,最后两位肯定为0,但是为了支持16位指令,仅做最低为0的保证.

包括:
	beq
	bne
	bge
	blt
	bltu
	bgeu

可跳转范围: $2^{-12}$  ~  $2^{12}-1$
即:+-4K的指令数

至于标签如何转化为地址,由处理器进行转化:pc+imm * 2
注:imm * 2 是做低位补0的处理

### J型指令

无条件跳转指令

![[Pasted image 20241015193619.png]]

仅有:jal指令

jal x1,Label

寻址范围:$-2^{20}$ ~ $2^{20}-1$
即:+-1M

跳转至Label,将pc+4存入x1

### U型指令 op rd imm

![[Pasted image 20241015194140.png]]

包括:lui,auipc

lui将立即数存入rd高20位,低12位清零
auipc将pc+imm<<12存入rd

## 寄存器分类

1. x0 0 zero
2. x1 返回地址 ra
3. x2 栈指针 sp
4. x3 全局指针 gp
5. x4 线程指针 tp
6. x5-x7,x28-x31 临时寄存器 (t0-t6)
7. x8 帧指针(函数栈帧末尾的指针)
8. x8,x9,x18-x27 保存寄存器 (s0-s11)
9. x10-x11 函数参数,返回值 a0,a1
10. x12-x17 函数参数 (a2-a7)

## 字符串

ascii
unicode

一个字符占用一个字节
字符串占有连续的存储空间

## 伪指令

```risc-v
mv rs1,rs2
j Label->jal x0,Label
jr x1->jalr x0,0(x1)
li x5 0xDEADBEEF(lui)
la x5,Label ->auipc
```

## 多线程指令 条件读取和存储

[[计算机组成原理-preview#多任务|多任务]]


# 第三章 ALU硬件和乘法运算

## ALU和加减法

通过电路和数据选择器来实现加减与或运算

overflow检测是否溢出，看操作数和结果的符号位就行

最高位加法器的输出set连接到最低位less的输入来实现slt指令

饱和算法:上溢取最大值,下溢取最小值

减法:a+b=a+~b+1

## 乘法

用到的部件:加法器,移位器,存储部分积,乘数和被乘数的寄存器

> 过程:
> 部分积初始化为全0
> 每个周期中顺序执行下列操作,执行乘数位数次
> 1. 判断乘数最低位是0还是1,若0不做操作,进行下一步.若1将被乘数加到部分积上,进行下一步
> 2. 被乘数左移一位,相当于×2
> 3. 乘数右移一位,高位补0

==注:==
上述操作中,被乘数需要左移32位,所以要用64位寄存器保存被乘数,同时用64位寄存器保存部分积,但是乘数只需要32位寄存器就行

 并行执行乘法操作:
 将乘数和积放在同一个寄存器中,如果乘数位为1,被乘数和乘数移位,被乘数加到积上.同时积寄存器增加到65位来保存加法器的进位,ALU缩减到32位ALU

## 浮点数

[[IEEE-754]]

根据浮点数计算的顺序:

加法:
1. 比较指数
2. 对齐
3. 加
4. 规格化
5. 舍入

乘法:
1. 指数相加,即对于IEEE-754中,指数位相加减去偏置量
2. 做乘法,按照可保存的小数位数进行保存
3. 规格化乘积
4. 检测是否溢出(指数位)
5. 规格化有多余的位数,进行舍入
6. 判断符号

## 浮点数寄存器

32个浮点数寄存器
f0~f31,f0没有硬连接到常数0
每个寄存器都有64位,单精度浮点数存储在低32位中
全部只用于浮点数操作

## 浮点数运算指令

在常规指令前加上f,再在后面加上.s或者.d表示单精度还是双精度

1. fadd.s fsub.s fmul.s fdiv.s fsqrt.s
2. fadd.d fsub.d fmul.d fdiv.d fsqrt.d
3. feq.s flt.s fle.s 等于 小于 小于等于
4. feq.d flt.d fle.d
	1. 比较结果0或1放在整数目的寄存器中 `feq.s x5,f1,f2 x5=1 if f1==f2`
	2. 再使用beq和bne来跳转
5. flw fld 取字,取双字
6. fsw fsd
7. B.cond 条件分支指令(了解)

