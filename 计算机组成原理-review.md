
# 第一章

## 七个伟大思想

1. 抽象简化设计
2. 加速经常性事件
3. 并行
4. 流水线
5. 预测
6. 存储层次
7. 通过冗余提高可靠性

## 性能

### 度量性能

1. 挂钟时间 响应时间 运行时间
包括:磁盘访问,内存访问,IO操作和os开销
2. cpu时间
只在cpu上花费的时间,包括用户cpu时间和系统cpu时间(操作系统帮用户执行的任务)

### 计算

1. cpu时间=cpu周期数 x 周期时间=周期数/cpu频率
2. cpu周期数=程序指令数 x 指令平均时钟周期数(CPI)
3. cpu时间=指令数 x CPI / cpu频率

注:
- cpu主频提高和周期数增加不成正比
- ISA称为指令集架构,相同指令集架构的CPI也不一定相同
- 在比较性能强弱时使用比值,强的做分子

### 计算-2

不同种类的指令的CPI不同,所以采用分层计算

eg.
![[Pasted image 20241015185809.png]]

## 影响程序性能的因素

| 硬件或软件指标  | 影响什么         |
| -------- | ------------ |
| 算法       | IC(指令数),cpi  |
| 编程语言     | 同上           |
| 编译器      | 同上           |
| 指令系统体系结构 | 指令数,时钟频率,cpi |

## 功耗墙

由于功耗限制
当功耗上升时,无法再降低硬件的电压和散出足够的热量
从而摩尔定律受到影响
现在处于后pc时代

# 第二章

除浮点数外的指令集:
[[计算机组成原理-en.pdf#page=278&selection=0,3,14,19|基本指令集]]

各种指令格式:
[[riscv基本指令集.pdf#page=1&selection=1,1,2,43|指令格式]]


## 指令类型

1. 运算指令
	1. 算数运算
	2. 逻辑运算
2. 数据传输
	1. load
	2. store
	3. 外设IO读取
3. 控制指令
	1. 条件分支
	2. 无条件分支

## 指令格式

### 概述

1. 指令固定为32位,四个字节
2. 操作码固定7位
3. 操作数长度25位
	1. 寄存器
	2. 内存
	3. 立即数

### R型指令 op rd rs1 rs2 opcode=0110011

![[Pasted image 20240920151101.png]]
包括:	
1. add,sub
2. sll,srl,sra
3. or,and,xor
4. slt,sltu(小于置位指令)

funct3和funct7区分具体指令
### I型指令 op rd rs imm 

![[Pasted image 20240920152324.png]]

包括:
1. addi,subi
2. slli,srli,srai
3. ori,andi,xori
4. slti,sltui
5. lb,lh,lw,lbu,lhu
6. ==jalr== jalr,x0,0(x1) 跳转到x1的地址,将pc+4存到x0,即舍弃pc+4

立即数范围: $-2^{11}$ ~ $2^{11}-1$


### S型指令 op rs1 imm(rs2)

![[Pasted image 20240920153828.png]]

包括:
	sb
	sh
	sw
	
为什么要把立即数拆开?
和R型指令保持一致
### SB型指令 op rs1 rs2 Label

![[Pasted image 20241015192827.png]]
第11位和12位的设计和S型指令保持一致
12位做最高位保持符号
最低位不存储,补0,因为指令的地址都是4的倍数,最后两位肯定为0,但是为了支持16位指令,仅做最低为0的保证.

包括:
	beq
	bne
	bge
	blt
	bltu
	bgeu

可跳转范围: $2^{-12}$  ~  $2^{12}-1$
即:+-4K的指令数

至于标签如何转化为地址,由处理器进行转化:pc+imm * 2
注:imm * 2 是做低位补0的处理

### J型指令

无条件跳转指令

![[Pasted image 20241015193619.png]]

仅有:jal指令

jal x1,Label

寻址范围:$-2^{20}$ ~ $2^{20}-1$
即:+-1M

跳转至Label,将pc+4存入x1

### U型指令 op rd imm

![[Pasted image 20241015194140.png]]

包括:lui,auipc

lui将立即数存入rd高20位,低12位清零
auipc将pc+imm<<12存入rd

## 寄存器分类

1. x0 0 zero
2. x1 返回地址 ra
3. x2 栈指针 sp
4. x3 全局指针 gp
5. x4 线程指针 tp
6. x5-x7,x28-x31 临时寄存器 (t0-t6)
7. x8 帧指针(函数栈帧末尾的指针)
8. x8,x9,x18-x27 保存寄存器 (s0-s11)
9. x10-x11 函数参数,返回值 a0,a1
10. x12-x17 函数参数 (a2-a7)

## 字符串

ascii
unicode

一个字符占用一个字节
字符串占有连续的存储空间

## 伪指令

```risc-v
mv rs1,rs2
j Label->jal x0,Label
jr x1->jalr x0,0(x1)
li x5 0xDEADBEEF(lui)
la x5,Label ->auipc
```

## 多线程指令 条件读取和存储

[[计算机组成原理-preview#多任务|多任务]]


# 第三章 ALU硬件和乘法运算

## ALU和加减法

通过电路和数据选择器来实现加减与或运算

overflow检测是否溢出，看操作数和结果的符号位就行

最高位加法器的输出set连接到最低位less的输入来实现slt指令

饱和算法:上溢取最大值,下溢取最小值

减法:a+b=a+~b+1

## 乘法

用到的部件:加法器,移位器,存储部分积,乘数和被乘数的寄存器

> 过程:
> 部分积初始化为全0
> 每个周期中顺序执行下列操作,执行乘数位数次
> 1. 判断乘数最低位是0还是1,若0不做操作,进行下一步.若1将被乘数加到部分积上,进行下一步
> 2. 被乘数左移一位,相当于×2
> 3. 乘数右移一位,高位补0

==注:==
上述操作中,被乘数需要左移32位,所以要用64位寄存器保存被乘数,同时用64位寄存器保存部分积,但是乘数只需要32位寄存器就行

 并行执行乘法操作:
 将乘数和积放在同一个寄存器中,如果乘数位为1,被乘数和乘数移位,被乘数加到积上.同时积寄存器增加到65位来保存加法器的进位,ALU缩减到32位ALU

## 浮点数

[[IEEE-754]]

根据浮点数计算的顺序:

加法:
1. 比较指数
2. 对齐
3. 加
4. 规格化
5. 舍入

乘法:
1. 指数相加,即对于IEEE-754中,指数位相加减去偏置量
2. 做乘法,按照可保存的小数位数进行保存
3. 规格化乘积
4. 检测是否溢出(指数位)
5. 规格化有多余的位数,进行舍入
6. 判断符号

## 浮点数寄存器

32个浮点数寄存器
f0~f31,f0没有硬连接到常数0
每个寄存器都有64位,单精度浮点数存储在低32位中
全部只用于浮点数操作

## 浮点数运算指令

在常规指令前加上f,再在后面加上.s或者.d表示单精度还是双精度

1. fadd.s fsub.s fmul.s fdiv.s fsqrt.s
2. fadd.d fsub.d fmul.d fdiv.d fsqrt.d
3. feq.s flt.s fle.s 等于 小于 小于等于
4. feq.d flt.d fle.d
	1. 比较结果0或1放在整数目的寄存器中 `feq.s x5,f1,f2 x5=1 if f1==f2`
	2. 再使用beq和bne来跳转
5. flw fld 取字,取双字
6. fsw fsd
7. B.cond 条件分支指令(了解)


# 第四章 CPU数据和控制通路

指令的执行都分为五个阶段：
1. 取指令IF
2. 译码和读寄存器 ID
3. 进行ALU计算相关数据 EX
4. 读取和写入内存 MEM
5. 写回寄存器WB
## 单周期处理器

### 数据通路设计

1. 取指令 从指令内存IMEM中取出指令
2. 译码和寄存器读取 解析指令，并在RF中读取寄存器内容 RF如下图所示：
![[Pasted image 20241016111941.png]]
其中左侧从上到下依次对应rs1,rs2,rd,要写入到rd的数据,右侧分别为rs1和rs2的具体值,当指令中没有rs2时,读出为乱码,数据随后流入ALU
3. ALU进行计算,根据不同的指令类型比如add rd rs1 rs2,addi rd rs1 rs2,lw rd,imm(rs1),sw rs2,imm(rs1)等,进行rs1和rs2或者rs1与imm的计算
4. 读内存和写内存,没什么好说的
5. 写回寄存器,要选择写回rd的是哪个数据,是ALU计算产生的还是从内存中读取到的数据

注意用到立即数的指令需要用到ImmGen立即数产生单元

为了满足branch指令,还需要用到ALU的zero值判断rs1和rs2是否相等,另外需要计算出pc + imm * 2 ,因此需要加上一个移位器和加法器

### 控制信号设计

根据指令的不同,设置不同的信号值来执行不同的操作,比如寄存器写,ALUSrc等,详见下表:
其中ALUOP是为了简化ALU输入而设计的

控制信号有两种实现办法:
1. 由输入的opcode和fun3和fun7,通过真值表和化简设计门电路来实现电路功能
2. 使用存储型控制器:只读存储器ROM,根据读入的opcode和fun3和fun7产生地址,在ROM对应地址处查询指令类型,输出对应控制信号

![图片](附件/Pasted%20image%2020241030190325.png)

因此整体的数据通路和控制通路设计如下:
![[Pasted image 20241018150350.png]]

### 最小周期时间

最小周期时间由指令中需要用到最多的功能部件的指令决定,在上面的指令中,lw决定了cpu周期的最小值应该大于等于lw指令所需的时间

## 多周期处理器

将cpu周期降到一个时间最长的操作需要的时间,比如读内存需要的200ps.
这样每个指令需要若干个cpu周期执行,比如lw需要5个cpu周期
但是在每个cpu周期内还是只有一个部件在执行工作,效率依旧不高,因此我们设计流水线处理器结构

## 流水线

### 相关概念

> 流水线级数

执行完一条指令需要哪几个步骤,如五级流水线:

1. IF:instruction fetch
2. ID:instruction decode & register read
3. EX: execute operation or caculate
4. MEM: access memory
5. WB:write back to register

> 加速比

取决于吞吐量的提高

### 五级流水线各步骤用到的部件

1. pc,IM,adder
2. RF
3. ALU
4. DM
5. RF

如何解决用到两次RF的问题?
RF所需的时间仅为100ps,所以在一个cpu周期(200ps)中,使用前半周期写,后半周期读
这样设计的目的是:保证读取数据可以读到正确的数据

既然同时有5条指令在执行,那如何解决一条指令执行过程中所需要的数据可能被修改的问题?
——在每两个功能部件之间加上寄存器,一共有四个,以相邻两个功能部件的名称命名:IF/ID,ID/EX,EX/MEM,MEM/WB

整体结构:

![[Pasted image 20241025144544.png]]
### 结构冒险

一个结构同时被两个操作用到,比如lw和IF都需要用到内存单元,所以我们设计指令内存单元IMEM和数据内存单元DMEM

### 数据冒险

数据冒险主要由指令执行过程中的数据依赖产生

如:
![](附件/Pasted%20image%2020241030193358.png)

在第二条指令的ID阶段需要读取x19寄存器的值,但是在第二个周期时第一条指令还在ID阶段,x19的值需要在第五个周期的前半周期结束后才是正确值.

有两个解决办法:
1. 阻塞(stall)
	1. 在sub取指后持续执行ID,直到读取到正确数据,阻塞两个周期
	2. 上图中的bubble只是一种形式化的表示,实际中sub在两个冒泡中仍在执行,只是一直在ID而已
2. 旁路Bypassing(前递Forwarding)
	1. 既然读寄存器的目的是送往ALU计算,那么即使读出来的数据不对,只要输入给ALU的数据对就好了,因此我们可以直接将上一条指令的ALU输出作为下一条指令的ALU输入,这称为EX旁路
	2. 如下图所示:
	3. 但是对于lw指令,如果下面指令和lw指令产生数据相关,那么需要在MEM阶段结束后读取到的数据才是对的,此时把MEM的数据在写回之前直接送给ALU,但是仍然需要耽误一个周期,详见下2图
![](附件/Pasted%20image%2020241030195330.png)

![](附件/Pasted%20image%2020241030195636.png)
### 控制冒险

来源于branch指令,在beq指令中,只有在第三个周期结束时才判断出是否分支,计算出pc+imm * 2,第四个周期才执行将分支地址写回pc的操作,因此有指令可能是被错误执行的

解决方法:
1. 阻塞:beq后的指令不执行,一直等到beq执行完成写回pc操作再取指
2. 预测:预测后面会不会发生分支
	1. 静态预测
	2. 动态预测

### 解决冒险之前的准备

在发生数据回流的情况时会出现问题,比如:第一条指令WB需要写回rd,此时rd的值已经是第四条指令的rd值,因此我们需要保存rd的值到流水线寄存器中

对于控制信号:
ALU控制器不变
IF和ID不需要信号
EX需要 ALUsrc ALUcontrol
MEM需要 MemWrite MemRead Branch PCsrc
WB需要 MemToReg RegWrite

设计为:控制器放在ID阶段产生控制信号,在每个流水线寄存器中添加控制信号存储
![](附件/Pasted%20image%2020241030202056.png)

### 数据冒险解决

> EX旁路

方法:ALU的输入多一个,来自于ALU的输出,多加一个控制信号选择输入信号的来源
控制信号的产生?即选择ALU输出作为输入的条件?
1. 下一条指令的rs1或rs2与当前指令的rd相同
	1. 由EX旁路的图可知,这个过程发生在针对当前指令的第四周期,此时rd存储在MEM/WB寄存器,下一条指令的rs1和rs2存储在ID/EXE中
2. 同时要保证rd不等于0,因为x0永远为0,依赖x0的没有意义,不需要给x0传送数据
3. 同时这条指令应该是需要写入rd寄存器的指令,它的RegWrite信号为1,这个信号在EX/MEM中

因此可以得到以下公式:
选择ALU输出作为输入,当且仅当:
EX/MEM rd=ID/EX rs1 or EX/MEM rd=ID/EX rs2
and
EX/MEM rd!=x0
and
EX/MEM RegWrite=1

> MEM旁路

方法:再给ALU输入加一个

条件:
1. 第一条指令的rd是第二条指令的rs1或rs2
2. 根据此时指令间的关系,得:

MEM/WB rd=ID/EX rs1 or MEM/WB rd = ID/EX rs2
and
MEM/WB rd!=x0
and
MEM/WB RegWrite=1

![](附件/Pasted%20image%2020241030203503.png)

![](附件/Pasted%20image%2020241030203515.png)

上述情况存在一些问题:
```risc-v
add x1,x2,x3
add x1,x1,x4
add x5,x1,x6
```
![](附件/5affef0fed7f89420878548a4ea11b42.jpg)

如上图,这里同时满足两个旁路的条件,本不该使用MEM旁路的也使用了MEM旁路,因此我们需要修改MEM旁路的条件:

1. 满足前面提到的MEM旁路的条件
2. 不满足前面提到的EX旁路的条件

即:

![](附件/e1ba03a1e8e3e15aee1d3432d35b91d9.jpg)
完整旁路图:

![](附件/Pasted%20image%2020241030205648.png)
